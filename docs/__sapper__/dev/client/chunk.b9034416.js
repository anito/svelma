import { a as noop, b as safe_not_equal, c as SvelteComponentDev, d as init, e as dispatch_dev, f as element, g as claim_element, h as children, i as detach_dev, j as attr_dev, k as add_location, l as toggle_class, m as listen_dev, n as insert_dev, o as append_dev, p as bubble, q as identity, r as is_function, s as assign, t as globals, u as onMount, v as exclude_internal_props, w as empty, x as group_outros, y as transition_out, z as check_outros, A as transition_in, B as create_slot, C as create_component, D as claim_component, E as mount_component, F as destroy_component, G as space, H as claim_space, I as set_attributes, J as get_slot_context, K as get_slot_changes, L as get_spread_update, M as add_render_callback, N as create_bidirectional_transition, O as flush, P as createEventDispatcher, Q as tick, R as text, S as claim_text, T as set_data_dev, U as run_all, V as set_input_value, W as binding_callbacks, X as setContext, Y as getContext, Z as set_store_value, _ as create_in_transition, $ as create_out_transition, a0 as get_spread_object, a1 as HtmlTag, a2 as now, a3 as loop, a4 as get_store_value, a5 as validate_store, a6 as component_subscribe, a7 as onDestroy, a8 as prevent_default, a9 as destroy_each, aa as beforeUpdate } from './chunk.0f951886.js';

const subscriber_queue = [];
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */
function writable(value, start = noop) {
    let stop;
    const subscribers = [];
    function set(new_value) {
        if (safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (let i = 0; i < subscribers.length; i += 1) {
                    const s = subscribers[i];
                    s[1]();
                    subscriber_queue.push(s, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = noop) {
        const subscriber = [run, invalidate];
        subscribers.push(subscriber);
        if (subscribers.length === 1) {
            stop = start(set) || noop;
        }
        run(value);
        return () => {
            const index = subscribers.indexOf(subscriber);
            if (index !== -1) {
                subscribers.splice(index, 1);
            }
            if (subscribers.length === 0) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}

/* Library/Server/Web/Data/Sites/svelma/src/components/Icon.svelte generated by Svelte v3.16.7 */

const file = "Library/Server/Web/Data/Sites/svelma/src/components/Icon.svelte";

function create_fragment(ctx) {
	let span;
	let i;
	let i_class_value;
	let span_class_value;
	let dispose;

	const block = {
		c: function create() {
			span = element("span");
			i = element("i");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			i = claim_element(span_nodes, "I", { class: true });
			children(i).forEach(detach_dev);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(i, "class", i_class_value = "" + (/*newPack*/ ctx[7] + " fa-" + /*icon*/ ctx[0] + " " + /*customClass*/ ctx[2] + " " + /*newCustomSize*/ ctx[5]));
			add_location(i, file, 52, 2, 1131);
			attr_dev(span, "class", span_class_value = "icon " + /*size*/ ctx[1] + " " + /*newType*/ ctx[6] + " " + (/*isRight*/ ctx[4] && "is-right" || ""));
			toggle_class(span, "is-clickable", /*isClickable*/ ctx[3]);
			add_location(span, file, 51, 0, 1018);
			dispose = listen_dev(span, "click", /*click_handler*/ ctx[11], false, false, false);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, i);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*newPack, icon, customClass, newCustomSize*/ 165 && i_class_value !== (i_class_value = "" + (/*newPack*/ ctx[7] + " fa-" + /*icon*/ ctx[0] + " " + /*customClass*/ ctx[2] + " " + /*newCustomSize*/ ctx[5]))) {
				attr_dev(i, "class", i_class_value);
			}

			if (dirty & /*size, newType, isRight*/ 82 && span_class_value !== (span_class_value = "icon " + /*size*/ ctx[1] + " " + /*newType*/ ctx[6] + " " + (/*isRight*/ ctx[4] && "is-right" || ""))) {
				attr_dev(span, "class", span_class_value);
			}

			if (dirty & /*size, newType, isRight, isClickable*/ 90) {
				toggle_class(span, "is-clickable", /*isClickable*/ ctx[3]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { type = "" } = $$props;
	let { pack = "fas" } = $$props;
	let { icon } = $$props;
	let { size = "" } = $$props;
	let { customClass = "" } = $$props;
	let { customSize = "" } = $$props;
	let { isClickable = false } = $$props;
	let { isRight = false } = $$props;
	let newCustomSize = "";
	let newType = "";

	const writable_props = [
		"type",
		"pack",
		"icon",
		"size",
		"customClass",
		"customSize",
		"isClickable",
		"isRight"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Icon> was created with unknown prop '${key}'`);
	});

	function click_handler(event) {
		bubble($$self, event);
	}

	$$self.$set = $$props => {
		if ("type" in $$props) $$invalidate(8, type = $$props.type);
		if ("pack" in $$props) $$invalidate(9, pack = $$props.pack);
		if ("icon" in $$props) $$invalidate(0, icon = $$props.icon);
		if ("size" in $$props) $$invalidate(1, size = $$props.size);
		if ("customClass" in $$props) $$invalidate(2, customClass = $$props.customClass);
		if ("customSize" in $$props) $$invalidate(10, customSize = $$props.customSize);
		if ("isClickable" in $$props) $$invalidate(3, isClickable = $$props.isClickable);
		if ("isRight" in $$props) $$invalidate(4, isRight = $$props.isRight);
	};

	$$self.$capture_state = () => {
		return {
			type,
			pack,
			icon,
			size,
			customClass,
			customSize,
			isClickable,
			isRight,
			newCustomSize,
			newType,
			newPack
		};
	};

	$$self.$inject_state = $$props => {
		if ("type" in $$props) $$invalidate(8, type = $$props.type);
		if ("pack" in $$props) $$invalidate(9, pack = $$props.pack);
		if ("icon" in $$props) $$invalidate(0, icon = $$props.icon);
		if ("size" in $$props) $$invalidate(1, size = $$props.size);
		if ("customClass" in $$props) $$invalidate(2, customClass = $$props.customClass);
		if ("customSize" in $$props) $$invalidate(10, customSize = $$props.customSize);
		if ("isClickable" in $$props) $$invalidate(3, isClickable = $$props.isClickable);
		if ("isRight" in $$props) $$invalidate(4, isRight = $$props.isRight);
		if ("newCustomSize" in $$props) $$invalidate(5, newCustomSize = $$props.newCustomSize);
		if ("newType" in $$props) $$invalidate(6, newType = $$props.newType);
		if ("newPack" in $$props) $$invalidate(7, newPack = $$props.newPack);
	};

	let newPack;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*pack*/ 512) {
			$: $$invalidate(7, newPack = pack || "fas");
		}

		if ($$self.$$.dirty & /*customSize, size*/ 1026) {
			$: {
				if (customSize) $$invalidate(5, newCustomSize = customSize); else {
					switch (size) {
						case "is-small":
							break;
						case "is-medium":
							$$invalidate(5, newCustomSize = "fa-lg");
							break;
						case "is-large":
							$$invalidate(5, newCustomSize = "fa-3x");
							break;
						default:
							$$invalidate(5, newCustomSize = "");
					}
				}
			}
		}

		if ($$self.$$.dirty & /*type*/ 256) {
			$: {
				if (!type) $$invalidate(6, newType = "");
				let splitType = [];

				if (typeof type === "string") {
					splitType = type.split("-");
				} else {
					for (let key in type) {
						if (type[key]) {
							splitType = key.split("-");
							break;
						}
					}
				}

				if (splitType.length <= 1) $$invalidate(6, newType = ""); else $$invalidate(6, newType = `has-text-${splitType[1]}`);
			}
		}
	};

	return [
		icon,
		size,
		customClass,
		isClickable,
		isRight,
		newCustomSize,
		newType,
		newPack,
		type,
		pack,
		customSize,
		click_handler
	];
}

class Icon extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			type: 8,
			pack: 9,
			icon: 0,
			size: 1,
			customClass: 2,
			customSize: 10,
			isClickable: 3,
			isRight: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Icon",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (/*icon*/ ctx[0] === undefined && !("icon" in props)) {
			console.warn("<Icon> was created without expected prop 'icon'");
		}
	}

	get type() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pack() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pack(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get icon() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set icon(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get customClass() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set customClass(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get customSize() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set customSize(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isClickable() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isClickable(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isRight() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isRight(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function cubicInOut(t) {
    return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;
}
function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function blur(node, { delay = 0, duration = 400, easing = cubicInOut, amount = 5, opacity = 0 }) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const f = style.filter === 'none' ? '' : style.filter;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (_t, u) => `opacity: ${target_opacity - (od * u)}; filter: ${f} blur(${u * amount}px);`
    };
}
function fade(node, { delay = 0, duration = 400, easing = identity }) {
    const o = +getComputedStyle(node).opacity;
    return {
        delay,
        duration,
        easing,
        css: t => `opacity: ${t * o}`
    };
}
function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 }) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
    };
}
function slide(node, { delay = 0, duration = 400, easing = cubicOut }) {
    const style = getComputedStyle(node);
    const opacity = +style.opacity;
    const height = parseFloat(style.height);
    const padding_top = parseFloat(style.paddingTop);
    const padding_bottom = parseFloat(style.paddingBottom);
    const margin_top = parseFloat(style.marginTop);
    const margin_bottom = parseFloat(style.marginBottom);
    const border_top_width = parseFloat(style.borderTopWidth);
    const border_bottom_width = parseFloat(style.borderBottomWidth);
    return {
        delay,
        duration,
        easing,
        css: t => `overflow: hidden;` +
            `opacity: ${Math.min(t * 20, 1) * opacity};` +
            `height: ${t * height}px;` +
            `padding-top: ${t * padding_top}px;` +
            `padding-bottom: ${t * padding_bottom}px;` +
            `margin-top: ${t * margin_top}px;` +
            `margin-bottom: ${t * margin_bottom}px;` +
            `border-top-width: ${t * border_top_width}px;` +
            `border-bottom-width: ${t * border_bottom_width}px;`
    };
}
function scale(node, { delay = 0, duration = 400, easing = cubicOut, start = 0, opacity = 0 }) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const sd = 1 - start;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (_t, u) => `
			transform: ${transform} scale(${1 - (sd * u)});
			opacity: ${target_opacity - (od * u)}
		`
    };
}
function draw(node, { delay = 0, speed, duration, easing = cubicInOut }) {
    const len = node.getTotalLength();
    if (duration === undefined) {
        if (speed === undefined) {
            duration = 800;
        }
        else {
            duration = len / speed;
        }
    }
    else if (typeof duration === 'function') {
        duration = duration(len);
    }
    return {
        delay,
        duration,
        easing,
        css: (t, u) => `stroke-dasharray: ${t * len} ${u * len}`
    };
}
function crossfade(_a) {
    var { fallback } = _a, defaults = __rest(_a, ["fallback"]);
    const to_receive = new Map();
    const to_send = new Map();
    function crossfade(from, node, params) {
        const { delay = 0, duration = d => Math.sqrt(d) * 30, easing = cubicOut } = assign(assign({}, defaults), params);
        const to = node.getBoundingClientRect();
        const dx = from.left - to.left;
        const dy = from.top - to.top;
        const dw = from.width / to.width;
        const dh = from.height / to.height;
        const d = Math.sqrt(dx * dx + dy * dy);
        const style = getComputedStyle(node);
        const transform = style.transform === 'none' ? '' : style.transform;
        const opacity = +style.opacity;
        return {
            delay,
            duration: is_function(duration) ? duration(d) : duration,
            easing,
            css: (t, u) => `
				opacity: ${t * opacity};
				transform-origin: top left;
				transform: ${transform} translate(${u * dx}px,${u * dy}px) scale(${t + (1 - t) * dw}, ${t + (1 - t) * dh});
			`
        };
    }
    function transition(items, counterparts, intro) {
        return (node, params) => {
            items.set(params.key, {
                rect: node.getBoundingClientRect()
            });
            return () => {
                if (counterparts.has(params.key)) {
                    const { rect } = counterparts.get(params.key);
                    counterparts.delete(params.key);
                    return crossfade(rect, node, params);
                }
                // if the node is disappearing altogether
                // (i.e. wasn't claimed by the other list)
                // then we need to supply an outro
                items.delete(params.key);
                return fallback && fallback(node, params, intro);
            };
        };
    }
    return [
        transition(to_send, to_receive, false),
        transition(to_receive, to_send, true)
    ];
}

var transitions = /*#__PURE__*/Object.freeze({
    blur: blur,
    crossfade: crossfade,
    draw: draw,
    fade: fade,
    fly: fly,
    scale: scale,
    slide: slide
});

function chooseAnimation(animation) {
  return typeof animation === 'function' ? animation : transitions[animation]
}

function isEnterKey(e) {
  return e.keyCode && e.keyCode === 13
}

function isEscKey(e) {
  return e.keyCode && e.keyCode === 27
}

function omit(obj, ...keysToOmit) {
  return Object.keys(obj).reduce((acc, key) => {
    if (keysToOmit.indexOf(key) === -1) acc[key] = obj[key];
    return acc
  }, {})
}

function typeToIcon(type) {
  switch (type) {
    case 'is-info':
      return 'info-circle'
    case 'is-success':
      return 'check-circle'
    case 'is-warning':
      return 'exclamation-triangle'
    case 'is-danger':
      return 'exclamation-circle'
    default:
      return null
  }
}

/* Library/Server/Web/Data/Sites/svelma/src/components/Button.svelte generated by Svelte v3.16.7 */

const { Error: Error_1 } = globals;
const file$1 = "Library/Server/Web/Data/Sites/svelma/src/components/Button.svelte";

// (78:22) 
function create_if_block_3(ctx) {
	let a;
	let t0;
	let span;
	let t1;
	let current;
	let dispose;
	let if_block0 = /*iconLeft*/ ctx[6] && create_if_block_5(ctx);
	const default_slot_template = /*$$slots*/ ctx[15].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);
	let if_block1 = /*iconRight*/ ctx[7] && create_if_block_4(ctx);
	let a_levels = [{ href: /*href*/ ctx[1] }, /*props*/ ctx[10]];
	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if (if_block0) if_block0.c();
			t0 = space();
			span = element("span");
			if (default_slot) default_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			a = claim_element(nodes, "A", { href: true });
			var a_nodes = children(a);
			if (if_block0) if_block0.l(a_nodes);
			t0 = claim_space(a_nodes);
			span = claim_element(a_nodes, "SPAN", {});
			var span_nodes = children(span);
			if (default_slot) default_slot.l(span_nodes);
			span_nodes.forEach(detach_dev);
			t1 = claim_space(a_nodes);
			if (if_block1) if_block1.l(a_nodes);
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(span, file$1, 89, 4, 2094);
			set_attributes(a, a_data);
			toggle_class(a, "is-inverted", /*inverted*/ ctx[3]);
			toggle_class(a, "is-loading", /*loading*/ ctx[2]);
			toggle_class(a, "is-outlined", /*outlined*/ ctx[4]);
			toggle_class(a, "is-rounded", /*rounded*/ ctx[5]);
			add_location(a, file$1, 78, 2, 1827);
			dispose = listen_dev(a, "click", /*click_handler_1*/ ctx[17], false, false, false);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			if (if_block0) if_block0.m(a, null);
			append_dev(a, t0);
			append_dev(a, span);

			if (default_slot) {
				default_slot.m(span, null);
			}

			append_dev(a, t1);
			if (if_block1) if_block1.m(a, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*iconLeft*/ ctx[6]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
					transition_in(if_block0, 1);
				} else {
					if_block0 = create_if_block_5(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(a, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (default_slot && default_slot.p && dirty & /*$$scope*/ 16384) {
				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[14], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, null));
			}

			if (/*iconRight*/ ctx[7]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
					transition_in(if_block1, 1);
				} else {
					if_block1 = create_if_block_4(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(a, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			set_attributes(a, get_spread_update(a_levels, [
				dirty & /*href*/ 2 && ({ href: /*href*/ ctx[1] }),
				dirty & /*props*/ 1024 && /*props*/ ctx[10]
			]));

			toggle_class(a, "is-inverted", /*inverted*/ ctx[3]);
			toggle_class(a, "is-loading", /*loading*/ ctx[2]);
			toggle_class(a, "is-outlined", /*outlined*/ ctx[4]);
			toggle_class(a, "is-rounded", /*rounded*/ ctx[5]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (if_block0) if_block0.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block1) if_block1.d();
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(78:22) ",
		ctx
	});

	return block;
}

// (60:0) {#if tag === 'button'}
function create_if_block(ctx) {
	let button;
	let t0;
	let span;
	let t1;
	let current;
	let dispose;
	let if_block0 = /*iconLeft*/ ctx[6] && create_if_block_2(ctx);
	const default_slot_template = /*$$slots*/ ctx[15].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);
	let if_block1 = /*iconRight*/ ctx[7] && create_if_block_1(ctx);
	let button_levels = [/*props*/ ctx[10]];
	let button_data = {};

	for (let i = 0; i < button_levels.length; i += 1) {
		button_data = assign(button_data, button_levels[i]);
	}

	const block = {
		c: function create() {
			button = element("button");
			if (if_block0) if_block0.c();
			t0 = space();
			span = element("span");
			if (default_slot) default_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			if (if_block0) if_block0.l(button_nodes);
			t0 = claim_space(button_nodes);
			span = claim_element(button_nodes, "SPAN", {});
			var span_nodes = children(span);
			if (default_slot) default_slot.l(span_nodes);
			span_nodes.forEach(detach_dev);
			t1 = claim_space(button_nodes);
			if (if_block1) if_block1.l(button_nodes);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(span, file$1, 70, 4, 1662);
			set_attributes(button, button_data);
			toggle_class(button, "is-inverted", /*inverted*/ ctx[3]);
			toggle_class(button, "is-loading", /*loading*/ ctx[2]);
			toggle_class(button, "is-outlined", /*outlined*/ ctx[4]);
			toggle_class(button, "is-rounded", /*rounded*/ ctx[5]);
			add_location(button, file$1, 60, 2, 1401);
			dispose = listen_dev(button, "click", /*click_handler*/ ctx[16], false, false, false);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			if (if_block0) if_block0.m(button, null);
			append_dev(button, t0);
			append_dev(button, span);

			if (default_slot) {
				default_slot.m(span, null);
			}

			append_dev(button, t1);
			if (if_block1) if_block1.m(button, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*iconLeft*/ ctx[6]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
					transition_in(if_block0, 1);
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(button, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (default_slot && default_slot.p && dirty & /*$$scope*/ 16384) {
				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[14], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, null));
			}

			if (/*iconRight*/ ctx[7]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
					transition_in(if_block1, 1);
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(button, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			set_attributes(button, get_spread_update(button_levels, [dirty & /*props*/ 1024 && /*props*/ ctx[10]]));
			toggle_class(button, "is-inverted", /*inverted*/ ctx[3]);
			toggle_class(button, "is-loading", /*loading*/ ctx[2]);
			toggle_class(button, "is-outlined", /*outlined*/ ctx[4]);
			toggle_class(button, "is-rounded", /*rounded*/ ctx[5]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (if_block0) if_block0.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block1) if_block1.d();
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(60:0) {#if tag === 'button'}",
		ctx
	});

	return block;
}

// (87:4) {#if iconLeft}
function create_if_block_5(ctx) {
	let current;

	const icon = new Icon({
			props: {
				pack: /*iconPack*/ ctx[8],
				icon: /*iconLeft*/ ctx[6],
				size: /*iconSize*/ ctx[9]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*iconPack*/ 256) icon_changes.pack = /*iconPack*/ ctx[8];
			if (dirty & /*iconLeft*/ 64) icon_changes.icon = /*iconLeft*/ ctx[6];
			if (dirty & /*iconSize*/ 512) icon_changes.size = /*iconSize*/ ctx[9];
			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(87:4) {#if iconLeft}",
		ctx
	});

	return block;
}

// (93:4) {#if iconRight}
function create_if_block_4(ctx) {
	let current;

	const icon = new Icon({
			props: {
				pack: /*iconPack*/ ctx[8],
				icon: /*iconRight*/ ctx[7],
				size: /*iconSize*/ ctx[9]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*iconPack*/ 256) icon_changes.pack = /*iconPack*/ ctx[8];
			if (dirty & /*iconRight*/ 128) icon_changes.icon = /*iconRight*/ ctx[7];
			if (dirty & /*iconSize*/ 512) icon_changes.size = /*iconSize*/ ctx[9];
			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(93:4) {#if iconRight}",
		ctx
	});

	return block;
}

// (68:4) {#if iconLeft}
function create_if_block_2(ctx) {
	let current;

	const icon = new Icon({
			props: {
				pack: /*iconPack*/ ctx[8],
				icon: /*iconLeft*/ ctx[6],
				size: /*iconSize*/ ctx[9]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*iconPack*/ 256) icon_changes.pack = /*iconPack*/ ctx[8];
			if (dirty & /*iconLeft*/ 64) icon_changes.icon = /*iconLeft*/ ctx[6];
			if (dirty & /*iconSize*/ 512) icon_changes.size = /*iconSize*/ ctx[9];
			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(68:4) {#if iconLeft}",
		ctx
	});

	return block;
}

// (74:4) {#if iconRight}
function create_if_block_1(ctx) {
	let current;

	const icon = new Icon({
			props: {
				pack: /*iconPack*/ ctx[8],
				icon: /*iconRight*/ ctx[7],
				size: /*iconSize*/ ctx[9]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*iconPack*/ 256) icon_changes.pack = /*iconPack*/ ctx[8];
			if (dirty & /*iconRight*/ 128) icon_changes.icon = /*iconRight*/ ctx[7];
			if (dirty & /*iconSize*/ 512) icon_changes.size = /*iconSize*/ ctx[9];
			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(74:4) {#if iconRight}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block, create_if_block_3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*tag*/ ctx[0] === "button") return 0;
		if (/*tag*/ ctx[0] === "a") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, -1))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { tag = "button" } = $$props;
	let { type = "" } = $$props;
	let { size = "" } = $$props;
	let { href = "" } = $$props;
	let { loading = false } = $$props;
	let { inverted = false } = $$props;
	let { outlined = false } = $$props;
	let { rounded = false } = $$props;
	let { iconLeft = null } = $$props;
	let { iconRight = null } = $$props;
	let { iconPack = null } = $$props;
	let iconSize = "";

	onMount(() => {
		if (!["button", "a"].includes(tag)) throw new Error(`'${tag}' cannot be used as a tag for a Bulma button`);
	});

	let { $$slots = {}, $$scope } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	function click_handler_1(event) {
		bubble($$self, event);
	}

	$$self.$set = $$new_props => {
		$$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("tag" in $$new_props) $$invalidate(0, tag = $$new_props.tag);
		if ("type" in $$new_props) $$invalidate(11, type = $$new_props.type);
		if ("size" in $$new_props) $$invalidate(12, size = $$new_props.size);
		if ("href" in $$new_props) $$invalidate(1, href = $$new_props.href);
		if ("loading" in $$new_props) $$invalidate(2, loading = $$new_props.loading);
		if ("inverted" in $$new_props) $$invalidate(3, inverted = $$new_props.inverted);
		if ("outlined" in $$new_props) $$invalidate(4, outlined = $$new_props.outlined);
		if ("rounded" in $$new_props) $$invalidate(5, rounded = $$new_props.rounded);
		if ("iconLeft" in $$new_props) $$invalidate(6, iconLeft = $$new_props.iconLeft);
		if ("iconRight" in $$new_props) $$invalidate(7, iconRight = $$new_props.iconRight);
		if ("iconPack" in $$new_props) $$invalidate(8, iconPack = $$new_props.iconPack);
		if ("$$scope" in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => {
		return {
			tag,
			type,
			size,
			href,
			loading,
			inverted,
			outlined,
			rounded,
			iconLeft,
			iconRight,
			iconPack,
			iconSize,
			props
		};
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
		if ("tag" in $$props) $$invalidate(0, tag = $$new_props.tag);
		if ("type" in $$props) $$invalidate(11, type = $$new_props.type);
		if ("size" in $$props) $$invalidate(12, size = $$new_props.size);
		if ("href" in $$props) $$invalidate(1, href = $$new_props.href);
		if ("loading" in $$props) $$invalidate(2, loading = $$new_props.loading);
		if ("inverted" in $$props) $$invalidate(3, inverted = $$new_props.inverted);
		if ("outlined" in $$props) $$invalidate(4, outlined = $$new_props.outlined);
		if ("rounded" in $$props) $$invalidate(5, rounded = $$new_props.rounded);
		if ("iconLeft" in $$props) $$invalidate(6, iconLeft = $$new_props.iconLeft);
		if ("iconRight" in $$props) $$invalidate(7, iconRight = $$new_props.iconRight);
		if ("iconPack" in $$props) $$invalidate(8, iconPack = $$new_props.iconPack);
		if ("iconSize" in $$props) $$invalidate(9, iconSize = $$new_props.iconSize);
		if ("props" in $$props) $$invalidate(10, props = $$new_props.props);
	};

	let props;

	$$self.$$.update = () => {
		$: $$invalidate(10, props = {
			...omit($$props, "loading", "inverted", "outlined", "rounded"),
			class: `button ${type} ${size} ${$$props.class || ""}`
		});

		if ($$self.$$.dirty & /*size*/ 4096) {
			$: {
				if (!size || size === "is-medium") {
					$$invalidate(9, iconSize = "is-small");
				} else if (size === "is-large") {
					$$invalidate(9, iconSize = "is-medium");
				} else {
					$$invalidate(9, iconSize = size);
				}
			}
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		tag,
		href,
		loading,
		inverted,
		outlined,
		rounded,
		iconLeft,
		iconRight,
		iconPack,
		iconSize,
		props,
		type,
		size,
		$$props,
		$$scope,
		$$slots,
		click_handler,
		click_handler_1
	];
}

class Button extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			tag: 0,
			type: 11,
			size: 12,
			href: 1,
			loading: 2,
			inverted: 3,
			outlined: 4,
			rounded: 5,
			iconLeft: 6,
			iconRight: 7,
			iconPack: 8
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Button",
			options,
			id: create_fragment$1.name
		});
	}

	get tag() {
		throw new Error_1("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tag(value) {
		throw new Error_1("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error_1("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error_1("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error_1("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error_1("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error_1("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error_1("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get loading() {
		throw new Error_1("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set loading(value) {
		throw new Error_1("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inverted() {
		throw new Error_1("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inverted(value) {
		throw new Error_1("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get outlined() {
		throw new Error_1("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set outlined(value) {
		throw new Error_1("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rounded() {
		throw new Error_1("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rounded(value) {
		throw new Error_1("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get iconLeft() {
		throw new Error_1("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set iconLeft(value) {
		throw new Error_1("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get iconRight() {
		throw new Error_1("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set iconRight(value) {
		throw new Error_1("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get iconPack() {
		throw new Error_1("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set iconPack(value) {
		throw new Error_1("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* Library/Server/Web/Data/Sites/svelma/src/components/Collapse.svelte generated by Svelte v3.16.7 */
const file$2 = "Library/Server/Web/Data/Sites/svelma/src/components/Collapse.svelte";
const get_trigger_slot_changes = dirty => ({});
const get_trigger_slot_context = ctx => ({});

// (27:2) {#if open}
function create_if_block$1(ctx) {
	let div;
	let div_transition;
	let current;
	const default_slot_template = /*$$slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "collapse-content");
			add_location(div, file$2, 27, 4, 666);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot && default_slot.p && dirty & /*$$scope*/ 16) {
				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[4], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null));
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);

			if (local) {
				add_render_callback(() => {
					if (!div_transition) div_transition = create_bidirectional_transition(div, /*_animation*/ ctx[1], {}, true);
					div_transition.run(1);
				});
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);

			if (local) {
				if (!div_transition) div_transition = create_bidirectional_transition(div, /*_animation*/ ctx[1], {}, false);
				div_transition.run(0);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			if (detaching && div_transition) div_transition.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(27:2) {#if open}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let div1;
	let div0;
	let t;
	let current;
	let dispose;
	const trigger_slot_template = /*$$slots*/ ctx[5].trigger;
	const trigger_slot = create_slot(trigger_slot_template, ctx, /*$$scope*/ ctx[4], get_trigger_slot_context);
	let if_block = /*open*/ ctx[0] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			if (trigger_slot) trigger_slot.c();
			t = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (trigger_slot) trigger_slot.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t = claim_space(div1_nodes);
			if (if_block) if_block.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "collapse-trigger");
			add_location(div0, file$2, 23, 2, 563);
			attr_dev(div1, "class", "collapse");
			add_location(div1, file$2, 22, 0, 538);
			dispose = listen_dev(div0, "click", /*toggle*/ ctx[2], false, false, false);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);

			if (trigger_slot) {
				trigger_slot.m(div0, null);
			}

			append_dev(div1, t);
			if (if_block) if_block.m(div1, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (trigger_slot && trigger_slot.p && dirty & /*$$scope*/ 16) {
				trigger_slot.p(get_slot_context(trigger_slot_template, ctx, /*$$scope*/ ctx[4], get_trigger_slot_context), get_slot_changes(trigger_slot_template, /*$$scope*/ ctx[4], dirty, get_trigger_slot_changes));
			}

			if (/*open*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(trigger_slot, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(trigger_slot, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (trigger_slot) trigger_slot.d(detaching);
			if (if_block) if_block.d();
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { open = true } = $$props;
	let { animation = "slide" } = $$props;
	let _animation = transitions[animation];

	function toggle() {
		$$invalidate(0, open = !open);
	}

	const writable_props = ["open", "animation"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Collapse> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ("open" in $$props) $$invalidate(0, open = $$props.open);
		if ("animation" in $$props) $$invalidate(3, animation = $$props.animation);
		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return { open, animation, _animation };
	};

	$$self.$inject_state = $$props => {
		if ("open" in $$props) $$invalidate(0, open = $$props.open);
		if ("animation" in $$props) $$invalidate(3, animation = $$props.animation);
		if ("_animation" in $$props) $$invalidate(1, _animation = $$props._animation);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*animation*/ 8) {
			$: $$invalidate(1, _animation = typeof animation === "function"
			? animation
			: transitions[animation]);
		}
	};

	return [open, _animation, toggle, animation, $$scope, $$slots];
}

class Collapse extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { open: 0, animation: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Collapse",
			options,
			id: create_fragment$2.name
		});
	}

	get open() {
		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set open(value) {
		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get animation() {
		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set animation(value) {
		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* Library/Server/Web/Data/Sites/svelma/src/components/Dialog/Dialog.svelte generated by Svelte v3.16.7 */
const file$3 = "Library/Server/Web/Data/Sites/svelma/src/components/Dialog/Dialog.svelte";

// (216:0) {#if active}
function create_if_block$2(ctx) {
	let div4;
	let div0;
	let t0;
	let div3;
	let t1;
	let section;
	let div2;
	let t2;
	let div1;
	let p;
	let t3;
	let t4;
	let footer;
	let t5;
	let button;
	let t6;
	let button_class_value;
	let div3_transition;
	let div4_class_value;
	let current;
	let dispose;
	let if_block0 = /*title*/ ctx[2] && create_if_block_4$1(ctx);
	let if_block1 = /*icon*/ ctx[6] && create_if_block_3$1(ctx);
	let if_block2 = /*hasInput*/ ctx[8] && create_if_block_2$1(ctx);
	let if_block3 = /*showCancel*/ ctx[9] && create_if_block_1$1(ctx);

	const block = {
		c: function create() {
			div4 = element("div");
			div0 = element("div");
			t0 = space();
			div3 = element("div");
			if (if_block0) if_block0.c();
			t1 = space();
			section = element("section");
			div2 = element("div");
			if (if_block1) if_block1.c();
			t2 = space();
			div1 = element("div");
			p = element("p");
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			footer = element("footer");
			if (if_block3) if_block3.c();
			t5 = space();
			button = element("button");
			t6 = text(/*confirmText*/ ctx[4]);
			this.h();
		},
		l: function claim(nodes) {
			div4 = claim_element(nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			div0 = claim_element(div4_nodes, "DIV", { class: true });
			children(div0).forEach(detach_dev);
			t0 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			if (if_block0) if_block0.l(div3_nodes);
			t1 = claim_space(div3_nodes);
			section = claim_element(div3_nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			div2 = claim_element(section_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			if (if_block1) if_block1.l(div2_nodes);
			t2 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			p = claim_element(div1_nodes, "P", {});
			var p_nodes = children(p);
			p_nodes.forEach(detach_dev);
			t3 = claim_space(div1_nodes);
			if (if_block2) if_block2.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			t4 = claim_space(div3_nodes);
			footer = claim_element(div3_nodes, "FOOTER", { class: true });
			var footer_nodes = children(footer);
			if (if_block3) if_block3.l(footer_nodes);
			t5 = claim_space(footer_nodes);
			button = claim_element(footer_nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t6 = claim_text(button_nodes, /*confirmText*/ ctx[4]);
			button_nodes.forEach(detach_dev);
			footer_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "modal-background");
			add_location(div0, file$3, 217, 4, 7887);
			add_location(p, file$3, 236, 12, 8662);
			attr_dev(div1, "class", "media-content");
			add_location(div1, file$3, 235, 10, 8622);
			attr_dev(div2, "class", "media");
			add_location(div2, file$3, 229, 8, 8425);
			attr_dev(section, "class", "modal-card-body svelte-fac1wo");
			toggle_class(section, "is-titleless", !/*title*/ ctx[2]);
			toggle_class(section, "is-flex", /*icon*/ ctx[6]);
			add_location(section, file$3, 228, 6, 8334);
			attr_dev(button, "class", button_class_value = "button " + /*type*/ ctx[11] + " svelte-fac1wo");
			add_location(button, file$3, 264, 8, 9467);
			attr_dev(footer, "class", "modal-card-foot svelte-fac1wo");
			add_location(footer, file$3, 255, 6, 9221);
			attr_dev(div3, "class", "modal-card svelte-fac1wo");
			add_location(div3, file$3, 218, 4, 7945);
			attr_dev(div4, "class", div4_class_value = "modal dialog " + /*size*/ ctx[10] + " is-active" + " svelte-fac1wo");
			add_location(div4, file$3, 216, 2, 7821);

			dispose = [
				listen_dev(div0, "click", /*close*/ ctx[21], false, false, false),
				listen_dev(button, "click", /*confirm*/ ctx[22], false, false, false)
			];
		},
		m: function mount(target, anchor) {
			insert_dev(target, div4, anchor);
			append_dev(div4, div0);
			append_dev(div4, t0);
			append_dev(div4, div3);
			if (if_block0) if_block0.m(div3, null);
			append_dev(div3, t1);
			append_dev(div3, section);
			append_dev(section, div2);
			if (if_block1) if_block1.m(div2, null);
			append_dev(div2, t2);
			append_dev(div2, div1);
			append_dev(div1, p);
			p.innerHTML = /*message*/ ctx[3];
			append_dev(div1, t3);
			if (if_block2) if_block2.m(div1, null);
			append_dev(div3, t4);
			append_dev(div3, footer);
			if (if_block3) if_block3.m(footer, null);
			append_dev(footer, t5);
			append_dev(footer, button);
			append_dev(button, t6);
			/*button_binding_1*/ ctx[36](button);
			/*div4_binding*/ ctx[37](div4);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*title*/ ctx[2]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4$1(ctx);
					if_block0.c();
					if_block0.m(div3, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*icon*/ ctx[6]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
					transition_in(if_block1, 1);
				} else {
					if_block1 = create_if_block_3$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div2, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*message*/ 8) p.innerHTML = /*message*/ ctx[3];
			if (/*hasInput*/ ctx[8]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_2$1(ctx);
					if_block2.c();
					if_block2.m(div1, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty[0] & /*title*/ 4) {
				toggle_class(section, "is-titleless", !/*title*/ ctx[2]);
			}

			if (dirty[0] & /*icon*/ 64) {
				toggle_class(section, "is-flex", /*icon*/ ctx[6]);
			}

			if (/*showCancel*/ ctx[9]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_1$1(ctx);
					if_block3.c();
					if_block3.m(footer, t5);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (!current || dirty[0] & /*confirmText*/ 16) set_data_dev(t6, /*confirmText*/ ctx[4]);

			if (!current || dirty[0] & /*type*/ 2048 && button_class_value !== (button_class_value = "button " + /*type*/ ctx[11] + " svelte-fac1wo")) {
				attr_dev(button, "class", button_class_value);
			}

			if (!current || dirty[0] & /*size*/ 1024 && div4_class_value !== (div4_class_value = "modal dialog " + /*size*/ ctx[10] + " is-active" + " svelte-fac1wo")) {
				attr_dev(div4, "class", div4_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);

			add_render_callback(() => {
				if (!div3_transition) div3_transition = create_bidirectional_transition(div3, /*_animation*/ ctx[18], /*animProps*/ ctx[12], true);
				div3_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(if_block1);
			if (!div3_transition) div3_transition = create_bidirectional_transition(div3, /*_animation*/ ctx[18], /*animProps*/ ctx[12], false);
			div3_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div4);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			/*button_binding_1*/ ctx[36](null);
			if (detaching && div3_transition) div3_transition.end();
			/*div4_binding*/ ctx[37](null);
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(216:0) {#if active}",
		ctx
	});

	return block;
}

// (220:6) {#if title}
function create_if_block_4$1(ctx) {
	let header;
	let p;
	let t;

	const block = {
		c: function create() {
			header = element("header");
			p = element("p");
			t = text(/*title*/ ctx[2]);
			this.h();
		},
		l: function claim(nodes) {
			header = claim_element(nodes, "HEADER", { class: true });
			var header_nodes = children(header);
			p = claim_element(header_nodes, "P", { class: true });
			var p_nodes = children(p);
			t = claim_text(p_nodes, /*title*/ ctx[2]);
			p_nodes.forEach(detach_dev);
			header_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", "modal-card-title");
			add_location(p, file$3, 221, 10, 8073);
			attr_dev(header, "class", "modal-card-head svelte-fac1wo");
			add_location(header, file$3, 220, 8, 8030);
		},
		m: function mount(target, anchor) {
			insert_dev(target, header, anchor);
			append_dev(header, p);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(header);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$1.name,
		type: "if",
		source: "(220:6) {#if title}",
		ctx
	});

	return block;
}

// (231:10) {#if icon}
function create_if_block_3$1(ctx) {
	let div;
	let current;

	const icon_1 = new Icon({
			props: {
				pack: /*iconPack*/ ctx[7],
				icon: /*icon*/ ctx[6],
				type: /*type*/ ctx[11],
				size: "is-large"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(icon_1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(icon_1.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "media-left");
			add_location(div, file$3, 231, 12, 8478);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(icon_1, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_1_changes = {};
			if (dirty[0] & /*iconPack*/ 128) icon_1_changes.pack = /*iconPack*/ ctx[7];
			if (dirty[0] & /*icon*/ 64) icon_1_changes.icon = /*icon*/ ctx[6];
			if (dirty[0] & /*type*/ 2048) icon_1_changes.type = /*type*/ ctx[11];
			icon_1.$set(icon_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(icon_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$1.name,
		type: "if",
		source: "(231:10) {#if icon}",
		ctx
	});

	return block;
}

// (239:12) {#if hasInput}
function create_if_block_2$1(ctx) {
	let div1;
	let div0;
	let input_1;
	let t0;
	let p;
	let t1;
	let dispose;
	let input_1_levels = [{ class: "input" }, /*newInputProps*/ ctx[19]];
	let input_1_data = {};

	for (let i = 0; i < input_1_levels.length; i += 1) {
		input_1_data = assign(input_1_data, input_1_levels[i]);
	}

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			input_1 = element("input");
			t0 = space();
			p = element("p");
			t1 = text(/*validationMessage*/ ctx[17]);
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			input_1 = claim_element(div0_nodes, "INPUT", { class: true });
			t0 = claim_space(div0_nodes);
			p = claim_element(div0_nodes, "P", { class: true });
			var p_nodes = children(p);
			t1 = claim_text(p_nodes, /*validationMessage*/ ctx[17]);
			p_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(input_1, input_1_data);
			toggle_class(input_1, "svelte-fac1wo", true);
			add_location(input_1, file$3, 241, 18, 8803);
			attr_dev(p, "class", "help is-danger");
			add_location(p, file$3, 247, 18, 9053);
			attr_dev(div0, "class", "control");
			add_location(div0, file$3, 240, 16, 8763);
			attr_dev(div1, "class", "field svelte-fac1wo");
			add_location(div1, file$3, 239, 14, 8727);

			dispose = [
				listen_dev(input_1, "input", /*input_1_input_handler*/ ctx[32]),
				listen_dev(input_1, "keyup", /*keyup_handler*/ ctx[34], false, false, false)
			];
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, input_1);
			set_input_value(input_1, /*prompt*/ ctx[0]);
			/*input_1_binding*/ ctx[33](input_1);
			append_dev(div0, t0);
			append_dev(div0, p);
			append_dev(p, t1);
		},
		p: function update(ctx, dirty) {
			set_attributes(input_1, get_spread_update(input_1_levels, [
				{ class: "input" },
				dirty[0] & /*newInputProps*/ 524288 && /*newInputProps*/ ctx[19]
			]));

			if (dirty[0] & /*prompt*/ 1 && input_1.value !== /*prompt*/ ctx[0]) {
				set_input_value(input_1, /*prompt*/ ctx[0]);
			}

			toggle_class(input_1, "svelte-fac1wo", true);
			if (dirty[0] & /*validationMessage*/ 131072) set_data_dev(t1, /*validationMessage*/ ctx[17]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			/*input_1_binding*/ ctx[33](null);
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(239:12) {#if hasInput}",
		ctx
	});

	return block;
}

// (257:8) {#if showCancel}
function create_if_block_1$1(ctx) {
	let button;
	let t;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			t = text(/*cancelText*/ ctx[5]);
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, /*cancelText*/ ctx[5]);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "class", "button svelte-fac1wo");
			add_location(button, file$3, 257, 10, 9289);
			dispose = listen_dev(button, "click", /*cancel*/ ctx[20], false, false, false);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t);
			/*button_binding*/ ctx[35](button);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*cancelText*/ 32) set_data_dev(t, /*cancelText*/ ctx[5]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			/*button_binding*/ ctx[35](null);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(257:8) {#if showCancel}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let if_block_anchor;
	let current;
	let dispose;
	let if_block = /*active*/ ctx[1] && create_if_block$2(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			dispose = listen_dev(window, "keydown", /*keydown*/ ctx[23], false, false, false);
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*active*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { title = "" } = $$props;
	let { message } = $$props;
	let { confirmText = "OK" } = $$props;
	let { cancelText = "Cancel" } = $$props;
	let { focusOn = "confirm" } = $$props;
	let { icon = "" } = $$props;
	let { iconPack = "" } = $$props;
	let { hasInput = false } = $$props;
	let { prompt = null } = $$props;
	let { showCancel = false } = $$props;
	let { size = "" } = $$props;
	let { type = "is-primary" } = $$props;
	let { active = true } = $$props;
	let { animation = "scale" } = $$props;
	let { animProps = { start: 1.2 } } = $$props;
	let { inputProps = {} } = $$props;
	let resolve;
	let { promise = new Promise(fulfil => resolve = fulfil) } = $$props;
	let { subComponent = null } = $$props;
	let { appendToBody = true } = $$props;
	let modal;
	let cancelButton;
	let confirmButton;
	let input;
	let validationMessage = "";
	const dispatch = createEventDispatcher();

	onMount(async () => {
		await tick();

		if (hasInput) {
			input.focus();
		} else if (focusOn === "cancel" && showCancel) {
			cancelButton.focus();
		} else {
			confirmButton.focus();
		}
	});

	function cancel() {
		resolve(hasInput ? null : false);
		close();
	}

	function close() {
		resolve(hasInput ? null : false);
		$$invalidate(1, active = false);
		dispatch("destroyed");
	}

	async function confirm() {
		if (input && !input.checkValidity()) {
			$$invalidate(17, validationMessage = input.validationMessage);
			await tick();
			input.select();
			return;
		}

		$$invalidate(17, validationMessage = "");
		resolve(hasInput ? prompt : true);
		close();
	}

	function keydown(e) {
		if (active && isEscKey(e)) {
			close();
		}
	}

	const writable_props = [
		"title",
		"message",
		"confirmText",
		"cancelText",
		"focusOn",
		"icon",
		"iconPack",
		"hasInput",
		"prompt",
		"showCancel",
		"size",
		"type",
		"active",
		"animation",
		"animProps",
		"inputProps",
		"promise",
		"subComponent",
		"appendToBody"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Dialog> was created with unknown prop '${key}'`);
	});

	function input_1_input_handler() {
		prompt = this.value;
		$$invalidate(0, prompt);
	}

	function input_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			$$invalidate(16, input = $$value);
		});
	}

	const keyup_handler = e => isEnterKey(e) && confirm();

	function button_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			$$invalidate(14, cancelButton = $$value);
		});
	}

	function button_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			$$invalidate(15, confirmButton = $$value);
		});
	}

	function div4_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			$$invalidate(13, modal = $$value);
		});
	}

	$$self.$set = $$props => {
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
		if ("message" in $$props) $$invalidate(3, message = $$props.message);
		if ("confirmText" in $$props) $$invalidate(4, confirmText = $$props.confirmText);
		if ("cancelText" in $$props) $$invalidate(5, cancelText = $$props.cancelText);
		if ("focusOn" in $$props) $$invalidate(24, focusOn = $$props.focusOn);
		if ("icon" in $$props) $$invalidate(6, icon = $$props.icon);
		if ("iconPack" in $$props) $$invalidate(7, iconPack = $$props.iconPack);
		if ("hasInput" in $$props) $$invalidate(8, hasInput = $$props.hasInput);
		if ("prompt" in $$props) $$invalidate(0, prompt = $$props.prompt);
		if ("showCancel" in $$props) $$invalidate(9, showCancel = $$props.showCancel);
		if ("size" in $$props) $$invalidate(10, size = $$props.size);
		if ("type" in $$props) $$invalidate(11, type = $$props.type);
		if ("active" in $$props) $$invalidate(1, active = $$props.active);
		if ("animation" in $$props) $$invalidate(25, animation = $$props.animation);
		if ("animProps" in $$props) $$invalidate(12, animProps = $$props.animProps);
		if ("inputProps" in $$props) $$invalidate(26, inputProps = $$props.inputProps);
		if ("promise" in $$props) $$invalidate(27, promise = $$props.promise);
		if ("subComponent" in $$props) $$invalidate(28, subComponent = $$props.subComponent);
		if ("appendToBody" in $$props) $$invalidate(29, appendToBody = $$props.appendToBody);
	};

	$$self.$capture_state = () => {
		return {
			title,
			message,
			confirmText,
			cancelText,
			focusOn,
			icon,
			iconPack,
			hasInput,
			prompt,
			showCancel,
			size,
			type,
			active,
			animation,
			animProps,
			inputProps,
			resolve,
			promise,
			subComponent,
			appendToBody,
			modal,
			cancelButton,
			confirmButton,
			input,
			validationMessage,
			_animation,
			newInputProps
		};
	};

	$$self.$inject_state = $$props => {
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
		if ("message" in $$props) $$invalidate(3, message = $$props.message);
		if ("confirmText" in $$props) $$invalidate(4, confirmText = $$props.confirmText);
		if ("cancelText" in $$props) $$invalidate(5, cancelText = $$props.cancelText);
		if ("focusOn" in $$props) $$invalidate(24, focusOn = $$props.focusOn);
		if ("icon" in $$props) $$invalidate(6, icon = $$props.icon);
		if ("iconPack" in $$props) $$invalidate(7, iconPack = $$props.iconPack);
		if ("hasInput" in $$props) $$invalidate(8, hasInput = $$props.hasInput);
		if ("prompt" in $$props) $$invalidate(0, prompt = $$props.prompt);
		if ("showCancel" in $$props) $$invalidate(9, showCancel = $$props.showCancel);
		if ("size" in $$props) $$invalidate(10, size = $$props.size);
		if ("type" in $$props) $$invalidate(11, type = $$props.type);
		if ("active" in $$props) $$invalidate(1, active = $$props.active);
		if ("animation" in $$props) $$invalidate(25, animation = $$props.animation);
		if ("animProps" in $$props) $$invalidate(12, animProps = $$props.animProps);
		if ("inputProps" in $$props) $$invalidate(26, inputProps = $$props.inputProps);
		if ("resolve" in $$props) resolve = $$props.resolve;
		if ("promise" in $$props) $$invalidate(27, promise = $$props.promise);
		if ("subComponent" in $$props) $$invalidate(28, subComponent = $$props.subComponent);
		if ("appendToBody" in $$props) $$invalidate(29, appendToBody = $$props.appendToBody);
		if ("modal" in $$props) $$invalidate(13, modal = $$props.modal);
		if ("cancelButton" in $$props) $$invalidate(14, cancelButton = $$props.cancelButton);
		if ("confirmButton" in $$props) $$invalidate(15, confirmButton = $$props.confirmButton);
		if ("input" in $$props) $$invalidate(16, input = $$props.input);
		if ("validationMessage" in $$props) $$invalidate(17, validationMessage = $$props.validationMessage);
		if ("_animation" in $$props) $$invalidate(18, _animation = $$props._animation);
		if ("newInputProps" in $$props) $$invalidate(19, newInputProps = $$props.newInputProps);
	};

	let _animation;
	let newInputProps;

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*animation*/ 33554432) {
			$: $$invalidate(18, _animation = chooseAnimation(animation));
		}

		if ($$self.$$.dirty[0] & /*modal, active, appendToBody*/ 536879106) {
			$: {
				if (modal && active && appendToBody) {
					modal.parentNode.removeChild(modal);
					document.body.appendChild(modal);
				}
			}
		}

		if ($$self.$$.dirty[0] & /*inputProps*/ 67108864) {
			$: $$invalidate(19, newInputProps = { required: true, ...inputProps });
		}
	};

	return [
		prompt,
		active,
		title,
		message,
		confirmText,
		cancelText,
		icon,
		iconPack,
		hasInput,
		showCancel,
		size,
		type,
		animProps,
		modal,
		cancelButton,
		confirmButton,
		input,
		validationMessage,
		_animation,
		newInputProps,
		cancel,
		close,
		confirm,
		keydown,
		focusOn,
		animation,
		inputProps,
		promise,
		subComponent,
		appendToBody,
		resolve,
		dispatch,
		input_1_input_handler,
		input_1_binding,
		keyup_handler,
		button_binding,
		button_binding_1,
		div4_binding
	];
}

class Dialog extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$3,
			create_fragment$3,
			safe_not_equal,
			{
				title: 2,
				message: 3,
				confirmText: 4,
				cancelText: 5,
				focusOn: 24,
				icon: 6,
				iconPack: 7,
				hasInput: 8,
				prompt: 0,
				showCancel: 9,
				size: 10,
				type: 11,
				active: 1,
				animation: 25,
				animProps: 12,
				inputProps: 26,
				promise: 27,
				subComponent: 28,
				appendToBody: 29
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Dialog",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (/*message*/ ctx[3] === undefined && !("message" in props)) {
			console.warn("<Dialog> was created without expected prop 'message'");
		}
	}

	get title() {
		return this.$$.ctx[2];
	}

	set title(title) {
		this.$set({ title });
		flush();
	}

	get message() {
		return this.$$.ctx[3];
	}

	set message(message) {
		this.$set({ message });
		flush();
	}

	get confirmText() {
		return this.$$.ctx[4];
	}

	set confirmText(confirmText) {
		this.$set({ confirmText });
		flush();
	}

	get cancelText() {
		return this.$$.ctx[5];
	}

	set cancelText(cancelText) {
		this.$set({ cancelText });
		flush();
	}

	get focusOn() {
		return this.$$.ctx[24];
	}

	set focusOn(focusOn) {
		this.$set({ focusOn });
		flush();
	}

	get icon() {
		return this.$$.ctx[6];
	}

	set icon(icon) {
		this.$set({ icon });
		flush();
	}

	get iconPack() {
		return this.$$.ctx[7];
	}

	set iconPack(iconPack) {
		this.$set({ iconPack });
		flush();
	}

	get hasInput() {
		return this.$$.ctx[8];
	}

	set hasInput(hasInput) {
		this.$set({ hasInput });
		flush();
	}

	get prompt() {
		return this.$$.ctx[0];
	}

	set prompt(prompt) {
		this.$set({ prompt });
		flush();
	}

	get showCancel() {
		return this.$$.ctx[9];
	}

	set showCancel(showCancel) {
		this.$set({ showCancel });
		flush();
	}

	get size() {
		return this.$$.ctx[10];
	}

	set size(size) {
		this.$set({ size });
		flush();
	}

	get type() {
		return this.$$.ctx[11];
	}

	set type(type) {
		this.$set({ type });
		flush();
	}

	get active() {
		return this.$$.ctx[1];
	}

	set active(active) {
		this.$set({ active });
		flush();
	}

	get animation() {
		return this.$$.ctx[25];
	}

	set animation(animation) {
		this.$set({ animation });
		flush();
	}

	get animProps() {
		return this.$$.ctx[12];
	}

	set animProps(animProps) {
		this.$set({ animProps });
		flush();
	}

	get inputProps() {
		return this.$$.ctx[26];
	}

	set inputProps(inputProps) {
		this.$set({ inputProps });
		flush();
	}

	get promise() {
		return this.$$.ctx[27];
	}

	set promise(promise) {
		this.$set({ promise });
		flush();
	}

	get subComponent() {
		return this.$$.ctx[28];
	}

	set subComponent(subComponent) {
		this.$set({ subComponent });
		flush();
	}

	get appendToBody() {
		return this.$$.ctx[29];
	}

	set appendToBody(appendToBody) {
		this.$set({ appendToBody });
		flush();
	}
}

function createDialog(props) {
  if (typeof props === 'string') props = { message: props };

  const dialog = new Dialog({
    target: document.body,
    props,
    intro: true,
  });

  dialog.$on('destroy', () => {
  });

  return dialog.promise
}

function alert(props) {
  return createDialog(props);
}

function confirm(props) {
  if (typeof props === 'string') props = { message: props };

  return createDialog({ showCancel: true, ...props });
}

function prompt(props) {
  if (typeof props === 'string') props = { message: props };

  return createDialog({ hasInput: true, confirmText: 'Done', ...props });
}

Dialog.alert = alert;
Dialog.confirm = confirm;
Dialog.prompt = prompt;

/* Library/Server/Web/Data/Sites/svelma/src/components/Field.svelte generated by Svelte v3.16.7 */
const file$4 = "Library/Server/Web/Data/Sites/svelma/src/components/Field.svelte";
const get_default_slot_changes = dirty => ({ statusType: dirty & /*type*/ 2 });
const get_default_slot_context = ctx => ({ statusType: /*type*/ ctx[1] });

// (39:2) {#if label}
function create_if_block_1$2(ctx) {
	let label_1;
	let t;

	const block = {
		c: function create() {
			label_1 = element("label");
			t = text(/*label*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			label_1 = claim_element(nodes, "LABEL", { for: true, class: true });
			var label_1_nodes = children(label_1);
			t = claim_text(label_1_nodes, /*label*/ ctx[0]);
			label_1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(label_1, "for", /*labelFor*/ ctx[3]);
			attr_dev(label_1, "class", "label");
			add_location(label_1, file$4, 39, 4, 792);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label_1, anchor);
			append_dev(label_1, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*label*/ 1) set_data_dev(t, /*label*/ ctx[0]);

			if (dirty & /*labelFor*/ 8) {
				attr_dev(label_1, "for", /*labelFor*/ ctx[3]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(39:2) {#if label}",
		ctx
	});

	return block;
}

// (43:2) {#if message}
function create_if_block$3(ctx) {
	let p;
	let t;
	let p_class_value;

	const block = {
		c: function create() {
			p = element("p");
			t = text(/*message*/ ctx[2]);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			t = claim_text(p_nodes, /*message*/ ctx[2]);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", p_class_value = "help " + /*type*/ ctx[1]);
			add_location(p, file$4, 43, 4, 901);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*message*/ 4) set_data_dev(t, /*message*/ ctx[2]);

			if (dirty & /*type*/ 2 && p_class_value !== (p_class_value = "help " + /*type*/ ctx[1])) {
				attr_dev(p, "class", p_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(43:2) {#if message}",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let div;
	let t0;
	let t1;
	let current;
	let if_block0 = /*label*/ ctx[0] && create_if_block_1$2(ctx);
	const default_slot_template = /*$$slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], get_default_slot_context);
	let if_block1 = /*message*/ ctx[2] && create_if_block$3(ctx);

	let div_levels = [
		/*props*/ ctx[5],
		{
			class: "field " + /*type*/ ctx[1] + " " + (/*$$props*/ ctx[6].class || "")
		},
		{ "has-icons-right": /*hasIcons*/ ctx[4] }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (default_slot) default_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true, "has-icons-right": true });
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (default_slot) default_slot.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(div, div_data);
			add_location(div, file$4, 37, 0, 687);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*label*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$2(ctx);
					if_block0.c();
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (default_slot && default_slot.p && dirty & /*$$scope, type*/ 258) {
				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[8], get_default_slot_context), get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, get_default_slot_changes));
			}

			if (/*message*/ ctx[2]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$3(ctx);
					if_block1.c();
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			set_attributes(div, get_spread_update(div_levels, [
				dirty & /*props*/ 32 && /*props*/ ctx[5],
				dirty & /*type, $$props*/ 66 && ({
					class: "field " + /*type*/ ctx[1] + " " + (/*$$props*/ ctx[6].class || "")
				}),
				dirty & /*hasIcons*/ 16 && ({ "has-icons-right": /*hasIcons*/ ctx[4] })
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { label = null } = $$props;
	let { type = "" } = $$props;
	let { message = "" } = $$props;
	let { labelFor = "" } = $$props;
	setContext("type", () => type);
	let hasIcons = false;
	let iconType = "";
	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("label" in $$new_props) $$invalidate(0, label = $$new_props.label);
		if ("type" in $$new_props) $$invalidate(1, type = $$new_props.type);
		if ("message" in $$new_props) $$invalidate(2, message = $$new_props.message);
		if ("labelFor" in $$new_props) $$invalidate(3, labelFor = $$new_props.labelFor);
		if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => {
		return {
			label,
			type,
			message,
			labelFor,
			hasIcons,
			iconType,
			props
		};
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
		if ("label" in $$props) $$invalidate(0, label = $$new_props.label);
		if ("type" in $$props) $$invalidate(1, type = $$new_props.type);
		if ("message" in $$props) $$invalidate(2, message = $$new_props.message);
		if ("labelFor" in $$props) $$invalidate(3, labelFor = $$new_props.labelFor);
		if ("hasIcons" in $$props) $$invalidate(4, hasIcons = $$new_props.hasIcons);
		if ("iconType" in $$props) iconType = $$new_props.iconType;
		if ("props" in $$props) $$invalidate(5, props = $$new_props.props);
	};

	let props;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*type*/ 2) {
			$: {
				if (["is-danger", "is-success"].includes(type)) {
					$$invalidate(4, hasIcons = true);
					iconType = type;
				}
			}
		}

		$: $$invalidate(5, props = { ...omit($$props, "class") });
	};

	$$props = exclude_internal_props($$props);

	return [
		label,
		type,
		message,
		labelFor,
		hasIcons,
		props,
		$$props,
		iconType,
		$$scope,
		$$slots
	];
}

class Field extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
			label: 0,
			type: 1,
			message: 2,
			labelFor: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Field",
			options,
			id: create_fragment$4.name
		});
	}

	get label() {
		throw new Error("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get message() {
		throw new Error("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set message(value) {
		throw new Error("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get labelFor() {
		throw new Error("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set labelFor(value) {
		throw new Error("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* Library/Server/Web/Data/Sites/svelma/src/components/Input.svelte generated by Svelte v3.16.7 */
const file$5 = "Library/Server/Web/Data/Sites/svelma/src/components/Input.svelte";

// (132:2) {:else}
function create_else_block(ctx) {
	let textarea;
	let dispose;

	let textarea_levels = [
		/*props*/ ctx[14],
		{ value: /*value*/ ctx[0] },
		{
			class: "textarea " + /*statusType*/ ctx[11] + "\n      " + /*size*/ ctx[2]
		},
		{ disabled: /*disabled*/ ctx[7] }
	];

	let textarea_data = {};

	for (let i = 0; i < textarea_levels.length; i += 1) {
		textarea_data = assign(textarea_data, textarea_levels[i]);
	}

	const block = {
		c: function create() {
			textarea = element("textarea");
			this.h();
		},
		l: function claim(nodes) {
			textarea = claim_element(nodes, "TEXTAREA", { value: true, class: true, disabled: true });
			children(textarea).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(textarea, textarea_data);
			toggle_class(textarea, "svelte-nhop5", true);
			add_location(textarea, file$5, 132, 4, 3481);

			dispose = [
				listen_dev(textarea, "input", /*onInput*/ ctx[18], false, false, false),
				listen_dev(textarea, "focus", /*onFocus*/ ctx[19], false, false, false),
				listen_dev(textarea, "blur", /*onBlur*/ ctx[20], false, false, false)
			];
		},
		m: function mount(target, anchor) {
			insert_dev(target, textarea, anchor);
			/*textarea_binding*/ ctx[25](textarea);
		},
		p: function update(ctx, dirty) {
			set_attributes(textarea, get_spread_update(textarea_levels, [
				dirty & /*props*/ 16384 && /*props*/ ctx[14],
				dirty & /*value*/ 1 && ({ value: /*value*/ ctx[0] }),
				dirty & /*statusType, size*/ 2052 && ({
					class: "textarea " + /*statusType*/ ctx[11] + "\n      " + /*size*/ ctx[2]
				}),
				dirty & /*disabled*/ 128 && ({ disabled: /*disabled*/ ctx[7] })
			]));

			toggle_class(textarea, "svelte-nhop5", true);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(textarea);
			/*textarea_binding*/ ctx[25](null);
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(132:2) {:else}",
		ctx
	});

	return block;
}

// (119:2) {#if type !== 'textarea'}
function create_if_block_2$2(ctx) {
	let input_1;
	let dispose;

	let input_1_levels = [
		/*props*/ ctx[14],
		{ type: /*newType*/ ctx[10] },
		{ value: /*value*/ ctx[0] },
		{
			class: "input " + /*statusType*/ ctx[11] + "\n      " + /*size*/ ctx[2] + "\n      " + (/*$$props*/ ctx[21].class || "")
		},
		{ disabled: /*disabled*/ ctx[7] }
	];

	let input_1_data = {};

	for (let i = 0; i < input_1_levels.length; i += 1) {
		input_1_data = assign(input_1_data, input_1_levels[i]);
	}

	const block = {
		c: function create() {
			input_1 = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input_1 = claim_element(nodes, "INPUT", {
				type: true,
				value: true,
				class: true,
				disabled: true
			});

			this.h();
		},
		h: function hydrate() {
			set_attributes(input_1, input_1_data);
			toggle_class(input_1, "svelte-nhop5", true);
			add_location(input_1, file$5, 119, 4, 3217);

			dispose = [
				listen_dev(input_1, "input", /*onInput*/ ctx[18], false, false, false),
				listen_dev(input_1, "focus", /*onFocus*/ ctx[19], false, false, false),
				listen_dev(input_1, "blur", /*onBlur*/ ctx[20], false, false, false)
			];
		},
		m: function mount(target, anchor) {
			insert_dev(target, input_1, anchor);
			/*input_1_binding*/ ctx[24](input_1);
		},
		p: function update(ctx, dirty) {
			set_attributes(input_1, get_spread_update(input_1_levels, [
				dirty & /*props*/ 16384 && /*props*/ ctx[14],
				dirty & /*newType*/ 1024 && ({ type: /*newType*/ ctx[10] }),
				dirty & /*value*/ 1 && ({ value: /*value*/ ctx[0] }),
				dirty & /*statusType, size, $$props*/ 2099204 && ({
					class: "input " + /*statusType*/ ctx[11] + "\n      " + /*size*/ ctx[2] + "\n      " + (/*$$props*/ ctx[21].class || "")
				}),
				dirty & /*disabled*/ 128 && ({ disabled: /*disabled*/ ctx[7] })
			]));

			toggle_class(input_1, "svelte-nhop5", true);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input_1);
			/*input_1_binding*/ ctx[24](null);
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$2.name,
		type: "if",
		source: "(119:2) {#if type !== 'textarea'}",
		ctx
	});

	return block;
}

// (145:2) {#if !loading && (passwordReveal || statusType)}
function create_if_block_1$3(ctx) {
	let current;

	const icon = new Icon({
			props: {
				pack: "fas",
				isRight: true,
				isClickable: /*passwordReveal*/ ctx[3],
				icon: /*passwordReveal*/ ctx[3]
				? /*passwordVisibleIcon*/ ctx[16]
				: /*statusTypeIcon*/ ctx[12],
				type: !/*passwordReveal*/ ctx[3]
				? /*statusType*/ ctx[11]
				: "is-primary"
			},
			$$inline: true
		});

	icon.$on("click", /*togglePasswordVisibility*/ ctx[17]);

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*passwordReveal*/ 8) icon_changes.isClickable = /*passwordReveal*/ ctx[3];

			if (dirty & /*passwordReveal, passwordVisibleIcon, statusTypeIcon*/ 69640) icon_changes.icon = /*passwordReveal*/ ctx[3]
			? /*passwordVisibleIcon*/ ctx[16]
			: /*statusTypeIcon*/ ctx[12];

			if (dirty & /*passwordReveal, statusType*/ 2056) icon_changes.type = !/*passwordReveal*/ ctx[3]
			? /*statusType*/ ctx[11]
			: "is-primary";

			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$3.name,
		type: "if",
		source: "(145:2) {#if !loading && (passwordReveal || statusType)}",
		ctx
	});

	return block;
}

// (157:2) {#if maxlength && hasCounter && type !== 'number'}
function create_if_block$4(ctx) {
	let small;
	let t0;
	let t1;
	let t2;

	const block = {
		c: function create() {
			small = element("small");
			t0 = text(/*valueLength*/ ctx[13]);
			t1 = text(" / ");
			t2 = text(/*maxlength*/ ctx[4]);
			this.h();
		},
		l: function claim(nodes) {
			small = claim_element(nodes, "SMALL", { class: true });
			var small_nodes = children(small);
			t0 = claim_text(small_nodes, /*valueLength*/ ctx[13]);
			t1 = claim_text(small_nodes, " / ");
			t2 = claim_text(small_nodes, /*maxlength*/ ctx[4]);
			small_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(small, "class", "help counter svelte-nhop5");
			toggle_class(small, "is-invisible", !/*isFocused*/ ctx[9]);
			add_location(small, file$5, 157, 4, 4115);
		},
		m: function mount(target, anchor) {
			insert_dev(target, small, anchor);
			append_dev(small, t0);
			append_dev(small, t1);
			append_dev(small, t2);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*valueLength*/ 8192) set_data_dev(t0, /*valueLength*/ ctx[13]);
			if (dirty & /*maxlength*/ 16) set_data_dev(t2, /*maxlength*/ ctx[4]);

			if (dirty & /*isFocused*/ 512) {
				toggle_class(small, "is-invisible", !/*isFocused*/ ctx[9]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(small);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(157:2) {#if maxlength && hasCounter && type !== 'number'}",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let div;
	let t0;
	let t1;
	let current;

	function select_block_type(ctx, dirty) {
		if (/*type*/ ctx[1] !== "textarea") return create_if_block_2$2;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block0 = current_block_type(ctx);
	let if_block1 = !/*loading*/ ctx[6] && (/*passwordReveal*/ ctx[3] || /*statusType*/ ctx[11]) && create_if_block_1$3(ctx);
	let if_block2 = /*maxlength*/ ctx[4] && /*hasCounter*/ ctx[5] && /*type*/ ctx[1] !== "number" && create_if_block$4(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if_block0.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block2) if_block2.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "control svelte-nhop5");
			toggle_class(div, "has-icons-right", /*hasIconRight*/ ctx[15]);
			toggle_class(div, "is-loading", /*loading*/ ctx[6]);
			add_location(div, file$5, 116, 0, 3098);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_block0.m(div, null);
			append_dev(div, t0);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t1);
			if (if_block2) if_block2.m(div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div, t0);
				}
			}

			if (!/*loading*/ ctx[6] && (/*passwordReveal*/ ctx[3] || /*statusType*/ ctx[11])) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
					transition_in(if_block1, 1);
				} else {
					if_block1 = create_if_block_1$3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*maxlength*/ ctx[4] && /*hasCounter*/ ctx[5] && /*type*/ ctx[1] !== "number") {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block$4(ctx);
					if_block2.c();
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty & /*hasIconRight*/ 32768) {
				toggle_class(div, "has-icons-right", /*hasIconRight*/ ctx[15]);
			}

			if (dirty & /*loading*/ 64) {
				toggle_class(div, "is-loading", /*loading*/ ctx[6]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { value = "" } = $$props;
	let { type = "text" } = $$props;
	let { size = "" } = $$props;
	let { passwordReveal = false } = $$props;
	let { maxlength = null } = $$props;
	let { hasCounter = true } = $$props;
	let { loading = false } = $$props;
	let { disabled = false } = $$props;
	let input;
	let isFocused;
	let isPasswordVisible = false;
	let newType = "text";
	let statusType = "";
	let statusTypeIcon = "";
	let valueLength = null;
	const getType = getContext("type");
	if (getType) statusType = getType() || "";

	onMount(() => {
		$$invalidate(10, newType = type);
	});

	async function togglePasswordVisibility() {
		$$invalidate(22, isPasswordVisible = !isPasswordVisible);
		$$invalidate(10, newType = isPasswordVisible ? "text" : "password");
		await tick();
		input.focus();
	}

	const onInput = e => {
		$$invalidate(0, value = e.target.value);
		set_store_value($props, $$props.value = value, $$props);
	};

	const onFocus = () => $$invalidate(9, isFocused = true);
	const onBlur = () => $$invalidate(9, isFocused = false);

	function input_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			$$invalidate(8, input = $$value);
		});
	}

	function textarea_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			$$invalidate(8, input = $$value);
		});
	}

	$$self.$set = $$new_props => {
		$$invalidate(21, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ("type" in $$new_props) $$invalidate(1, type = $$new_props.type);
		if ("size" in $$new_props) $$invalidate(2, size = $$new_props.size);
		if ("passwordReveal" in $$new_props) $$invalidate(3, passwordReveal = $$new_props.passwordReveal);
		if ("maxlength" in $$new_props) $$invalidate(4, maxlength = $$new_props.maxlength);
		if ("hasCounter" in $$new_props) $$invalidate(5, hasCounter = $$new_props.hasCounter);
		if ("loading" in $$new_props) $$invalidate(6, loading = $$new_props.loading);
		if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
	};

	$$self.$capture_state = () => {
		return {
			value,
			type,
			size,
			passwordReveal,
			maxlength,
			hasCounter,
			loading,
			disabled,
			input,
			isFocused,
			isPasswordVisible,
			newType,
			statusType,
			statusTypeIcon,
			valueLength,
			props,
			hasIconRight,
			passwordVisibleIcon
		};
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(21, $$props = assign(assign({}, $$props), $$new_props));
		if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
		if ("type" in $$props) $$invalidate(1, type = $$new_props.type);
		if ("size" in $$props) $$invalidate(2, size = $$new_props.size);
		if ("passwordReveal" in $$props) $$invalidate(3, passwordReveal = $$new_props.passwordReveal);
		if ("maxlength" in $$props) $$invalidate(4, maxlength = $$new_props.maxlength);
		if ("hasCounter" in $$props) $$invalidate(5, hasCounter = $$new_props.hasCounter);
		if ("loading" in $$props) $$invalidate(6, loading = $$new_props.loading);
		if ("disabled" in $$props) $$invalidate(7, disabled = $$new_props.disabled);
		if ("input" in $$props) $$invalidate(8, input = $$new_props.input);
		if ("isFocused" in $$props) $$invalidate(9, isFocused = $$new_props.isFocused);
		if ("isPasswordVisible" in $$props) $$invalidate(22, isPasswordVisible = $$new_props.isPasswordVisible);
		if ("newType" in $$props) $$invalidate(10, newType = $$new_props.newType);
		if ("statusType" in $$props) $$invalidate(11, statusType = $$new_props.statusType);
		if ("statusTypeIcon" in $$props) $$invalidate(12, statusTypeIcon = $$new_props.statusTypeIcon);
		if ("valueLength" in $$props) $$invalidate(13, valueLength = $$new_props.valueLength);
		if ("props" in $$props) $$invalidate(14, props = $$new_props.props);
		if ("hasIconRight" in $$props) $$invalidate(15, hasIconRight = $$new_props.hasIconRight);
		if ("passwordVisibleIcon" in $$props) $$invalidate(16, passwordVisibleIcon = $$new_props.passwordVisibleIcon);
	};

	let props;
	let hasIconRight;
	let passwordVisibleIcon;

	$$self.$$.update = () => {
		$: $$invalidate(14, props = {
			...omit($$props, "class", "value", "type", "size", "passwordReveal", "hasCounter", "loading", "disabled")
		});

		if ($$self.$$.dirty & /*passwordReveal, loading, statusType*/ 2120) {
			$: $$invalidate(15, hasIconRight = passwordReveal || loading || statusType);
		}

		if ($$self.$$.dirty & /*isPasswordVisible*/ 4194304) {
			$: $$invalidate(16, passwordVisibleIcon = isPasswordVisible ? "eye-slash" : "eye");
		}

		if ($$self.$$.dirty & /*statusType*/ 2048) {
			$: {
				switch (statusType) {
					case "is-success":
						$$invalidate(12, statusTypeIcon = "check");
						break;
					case "is-danger":
						$$invalidate(12, statusTypeIcon = "exclamation-circle");
						break;
					case "is-info":
						$$invalidate(12, statusTypeIcon = "info-circle");
						break;
					case "is-warning":
						$$invalidate(12, statusTypeIcon = "exclamation-triangle");
						break;
				}
			}
		}

		if ($$self.$$.dirty & /*value*/ 1) {
			$: {
				if (typeof value === "string") {
					$$invalidate(13, valueLength = value.length);
				} else if (typeof value === "number") {
					$$invalidate(13, valueLength = value.toString().length);
				} else {
					$$invalidate(13, valueLength = 0);
				}
			}
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		value,
		type,
		size,
		passwordReveal,
		maxlength,
		hasCounter,
		loading,
		disabled,
		input,
		isFocused,
		newType,
		statusType,
		statusTypeIcon,
		valueLength,
		props,
		hasIconRight,
		passwordVisibleIcon,
		togglePasswordVisibility,
		onInput,
		onFocus,
		onBlur,
		$$props,
		isPasswordVisible,
		getType,
		input_1_binding,
		textarea_binding
	];
}

class Input extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
			value: 0,
			type: 1,
			size: 2,
			passwordReveal: 3,
			maxlength: 4,
			hasCounter: 5,
			loading: 6,
			disabled: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Input",
			options,
			id: create_fragment$5.name
		});
	}

	get value() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get passwordReveal() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set passwordReveal(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get maxlength() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set maxlength(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hasCounter() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hasCounter(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get loading() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set loading(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* Library/Server/Web/Data/Sites/svelma/src/components/Message.svelte generated by Svelte v3.16.7 */
const file$6 = "Library/Server/Web/Data/Sites/svelma/src/components/Message.svelte";

// (67:0) {#if active}
function create_if_block$5(ctx) {
	let article;
	let t0;
	let section;
	let div1;
	let t1;
	let div0;
	let article_class_value;
	let article_transition;
	let current;
	let if_block0 = (/*title*/ ctx[2] || /*showClose*/ ctx[3]) && create_if_block_2$3(ctx);
	let if_block1 = /*icon*/ ctx[5] && create_if_block_1$4(ctx);
	const default_slot_template = /*$$slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

	const block = {
		c: function create() {
			article = element("article");
			if (if_block0) if_block0.c();
			t0 = space();
			section = element("section");
			div1 = element("div");
			if (if_block1) if_block1.c();
			t1 = space();
			div0 = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			article = claim_element(nodes, "ARTICLE", { class: true });
			var article_nodes = children(article);
			if (if_block0) if_block0.l(article_nodes);
			t0 = claim_space(article_nodes);
			section = claim_element(article_nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			div1 = claim_element(section_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (if_block1) if_block1.l(div1_nodes);
			t1 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (default_slot) default_slot.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			article_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "media-content");
			add_location(div0, file$6, 85, 8, 2311);
			attr_dev(div1, "class", "media svelte-1eemcsd");
			add_location(div1, file$6, 79, 6, 2151);
			attr_dev(section, "class", "message-body");
			add_location(section, file$6, 78, 4, 2114);
			attr_dev(article, "class", article_class_value = "message " + /*type*/ ctx[1] + " " + /*size*/ ctx[4] + " svelte-1eemcsd");
			add_location(article, file$6, 67, 2, 1783);
		},
		m: function mount(target, anchor) {
			insert_dev(target, article, anchor);
			if (if_block0) if_block0.m(article, null);
			append_dev(article, t0);
			append_dev(article, section);
			append_dev(section, div1);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t1);
			append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*title*/ ctx[2] || /*showClose*/ ctx[3]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$3(ctx);
					if_block0.c();
					if_block0.m(article, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*icon*/ ctx[5]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
					transition_in(if_block1, 1);
				} else {
					if_block1 = create_if_block_1$4(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (default_slot && default_slot.p && dirty & /*$$scope*/ 8192) {
				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[13], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null));
			}

			if (!current || dirty & /*type, size*/ 18 && article_class_value !== (article_class_value = "message " + /*type*/ ctx[1] + " " + /*size*/ ctx[4] + " svelte-1eemcsd")) {
				attr_dev(article, "class", article_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);
			transition_in(default_slot, local);

			if (local) {
				add_render_callback(() => {
					if (!article_transition) article_transition = create_bidirectional_transition(article, fade, {}, true);
					article_transition.run(1);
				});
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(if_block1);
			transition_out(default_slot, local);

			if (local) {
				if (!article_transition) article_transition = create_bidirectional_transition(article, fade, {}, false);
				article_transition.run(0);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(article);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			if (detaching && article_transition) article_transition.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$5.name,
		type: "if",
		source: "(67:0) {#if active}",
		ctx
	});

	return block;
}

// (69:4) {#if title || showClose}
function create_if_block_2$3(ctx) {
	let div;
	let t;
	let if_block0 = /*title*/ ctx[2] && create_if_block_4$2(ctx);
	let if_block1 = /*showClose*/ ctx[3] && create_if_block_3$2(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "message-header svelte-1eemcsd");
			add_location(div, file$6, 69, 6, 1880);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t);
			if (if_block1) if_block1.m(div, null);
		},
		p: function update(ctx, dirty) {
			if (/*title*/ ctx[2]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4$2(ctx);
					if_block0.c();
					if_block0.m(div, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*showClose*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_3$2(ctx);
					if_block1.c();
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$3.name,
		type: "if",
		source: "(69:4) {#if title || showClose}",
		ctx
	});

	return block;
}

// (71:8) {#if title}
function create_if_block_4$2(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(/*title*/ ctx[2]);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t = claim_text(p_nodes, /*title*/ ctx[2]);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file$6, 71, 10, 1939);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$2.name,
		type: "if",
		source: "(71:8) {#if title}",
		ctx
	});

	return block;
}

// (74:8) {#if showClose}
function create_if_block_3$2(ctx) {
	let button;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true, "aria-label": true });
			children(button).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "class", "delete");
			attr_dev(button, "aria-label", "ariaCloseLabel");
			add_location(button, file$6, 74, 10, 2002);

			dispose = listen_dev(
				button,
				"click",
				function () {
					if (is_function(/*close*/ ctx[6])) /*close*/ ctx[6].apply(this, arguments);
				},
				false,
				false,
				false
			);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$2.name,
		type: "if",
		source: "(74:8) {#if showClose}",
		ctx
	});

	return block;
}

// (81:8) {#if icon}
function create_if_block_1$4(ctx) {
	let div;
	let current;

	const icon_1 = new Icon({
			props: {
				icon: /*icon*/ ctx[5],
				size: /*newIconSize*/ ctx[7]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(icon_1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(icon_1.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "media-left");
			add_location(div, file$6, 81, 10, 2200);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(icon_1, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_1_changes = {};
			if (dirty & /*icon*/ 32) icon_1_changes.icon = /*icon*/ ctx[5];
			if (dirty & /*newIconSize*/ 128) icon_1_changes.size = /*newIconSize*/ ctx[7];
			icon_1.$set(icon_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(icon_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$4.name,
		type: "if",
		source: "(81:8) {#if icon}",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*active*/ ctx[0] && create_if_block$5(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*active*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block$5(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let { type = "" } = $$props;
	let { active = true } = $$props;
	let { title = "" } = $$props;
	let { showClose = true } = $$props;
	let { autoClose = false } = $$props;
	let { duration = 5000 } = $$props;
	let { size = "" } = $$props;
	let { iconSize = "" } = $$props;
	let { ariaCloseLabel = "delete" } = $$props;
	let icon;
	const dispatch = createEventDispatcher();

	if (autoClose) {
		setTimeout(
			() => {
				$$invalidate(6, close = true);
			},
			duration
		);
	}

	function close() {
		$$invalidate(0, active = false);
		dispatch("close", active);
	}

	const writable_props = [
		"type",
		"active",
		"title",
		"showClose",
		"autoClose",
		"duration",
		"size",
		"iconSize",
		"ariaCloseLabel"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Message> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ("type" in $$props) $$invalidate(1, type = $$props.type);
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
		if ("showClose" in $$props) $$invalidate(3, showClose = $$props.showClose);
		if ("autoClose" in $$props) $$invalidate(8, autoClose = $$props.autoClose);
		if ("duration" in $$props) $$invalidate(9, duration = $$props.duration);
		if ("size" in $$props) $$invalidate(4, size = $$props.size);
		if ("iconSize" in $$props) $$invalidate(10, iconSize = $$props.iconSize);
		if ("ariaCloseLabel" in $$props) $$invalidate(11, ariaCloseLabel = $$props.ariaCloseLabel);
		if ("$$scope" in $$props) $$invalidate(13, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return {
			type,
			active,
			title,
			showClose,
			autoClose,
			duration,
			size,
			iconSize,
			ariaCloseLabel,
			icon,
			newIconSize
		};
	};

	$$self.$inject_state = $$props => {
		if ("type" in $$props) $$invalidate(1, type = $$props.type);
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
		if ("showClose" in $$props) $$invalidate(3, showClose = $$props.showClose);
		if ("autoClose" in $$props) $$invalidate(8, autoClose = $$props.autoClose);
		if ("duration" in $$props) $$invalidate(9, duration = $$props.duration);
		if ("size" in $$props) $$invalidate(4, size = $$props.size);
		if ("iconSize" in $$props) $$invalidate(10, iconSize = $$props.iconSize);
		if ("ariaCloseLabel" in $$props) $$invalidate(11, ariaCloseLabel = $$props.ariaCloseLabel);
		if ("icon" in $$props) $$invalidate(5, icon = $$props.icon);
		if ("newIconSize" in $$props) $$invalidate(7, newIconSize = $$props.newIconSize);
	};

	let newIconSize;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*iconSize, size*/ 1040) {
			$: $$invalidate(7, newIconSize = iconSize || size || "is-large");
		}

		if ($$self.$$.dirty & /*type*/ 2) {
			$: {
				switch (type) {
					case "is-info":
						$$invalidate(5, icon = "info-circle");
						break;
					case "is-success":
						$$invalidate(5, icon = "check-circle");
						break;
					case "is-warning":
						$$invalidate(5, icon = "exclamation-triangle");
						break;
					case "is-danger":
						$$invalidate(5, icon = "exclamation-circle");
						break;
					default:
						$$invalidate(5, icon = null);
				}
			}
		}
	};

	return [
		active,
		type,
		title,
		showClose,
		size,
		icon,
		close,
		newIconSize,
		autoClose,
		duration,
		iconSize,
		ariaCloseLabel,
		dispatch,
		$$scope,
		$$slots
	];
}

class Message extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$6, create_fragment$6, safe_not_equal, {
			type: 1,
			active: 0,
			title: 2,
			showClose: 3,
			autoClose: 8,
			duration: 9,
			size: 4,
			iconSize: 10,
			ariaCloseLabel: 11
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Message",
			options,
			id: create_fragment$6.name
		});
	}

	get type() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get showClose() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showClose(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autoClose() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autoClose(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get duration() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set duration(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get iconSize() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set iconSize(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaCloseLabel() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaCloseLabel(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* Library/Server/Web/Data/Sites/svelma/src/components/Modal/Modal.svelte generated by Svelte v3.16.7 */
const file$7 = "Library/Server/Web/Data/Sites/svelma/src/components/Modal/Modal.svelte";

// (40:0) {#if active}
function create_if_block$6(ctx) {
	let div3;
	let div0;
	let t0;
	let div2;
	let t1;
	let div1;
	let div2_transition;
	let t2;
	let div3_class_value;
	let current;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
	let if_block = /*showClose*/ ctx[3] && create_if_block_1$5(ctx);

	const block = {
		c: function create() {
			div3 = element("div");
			div0 = element("div");
			t0 = space();
			div2 = element("div");
			if (default_slot) default_slot.c();
			t1 = space();
			div1 = element("div");
			t2 = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			div0 = claim_element(div3_nodes, "DIV", { class: true });
			children(div0).forEach(detach_dev);
			t0 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			if (default_slot) default_slot.l(div2_nodes);
			t1 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			children(div1).forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			t2 = claim_space(div3_nodes);
			if (if_block) if_block.l(div3_nodes);
			div3_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "modal-background");
			add_location(div0, file$7, 41, 4, 816);
			attr_dev(div1, "class", "sub-component");
			add_location(div1, file$7, 44, 6, 1000);
			attr_dev(div2, "class", "modal-content");
			add_location(div2, file$7, 42, 4, 874);
			attr_dev(div3, "class", div3_class_value = "modal " + /*size*/ ctx[2] + " is-active");
			add_location(div3, file$7, 40, 2, 757);
			dispose = listen_dev(div0, "click", /*close*/ ctx[6], false, false, false);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div0);
			append_dev(div3, t0);
			append_dev(div3, div2);

			if (default_slot) {
				default_slot.m(div2, null);
			}

			append_dev(div2, t1);
			append_dev(div2, div1);
			append_dev(div3, t2);
			if (if_block) if_block.m(div3, null);
			/*div3_binding*/ ctx[13](div3);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot && default_slot.p && dirty & /*$$scope*/ 2048) {
				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[11], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null));
			}

			if (/*showClose*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$5(ctx);
					if_block.c();
					if_block.m(div3, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (!current || dirty & /*size*/ 4 && div3_class_value !== (div3_class_value = "modal " + /*size*/ ctx[2] + " is-active")) {
				attr_dev(div3, "class", div3_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);

			if (local) {
				add_render_callback(() => {
					if (!div2_transition) div2_transition = create_bidirectional_transition(div2, /*_animation*/ ctx[5], /*animProps*/ ctx[1], true);
					div2_transition.run(1);
				});
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);

			if (local) {
				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, /*_animation*/ ctx[5], /*animProps*/ ctx[1], false);
				div2_transition.run(0);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			if (default_slot) default_slot.d(detaching);
			if (detaching && div2_transition) div2_transition.end();
			if (if_block) if_block.d();
			/*div3_binding*/ ctx[13](null);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$6.name,
		type: "if",
		source: "(40:0) {#if active}",
		ctx
	});

	return block;
}

// (47:4) {#if showClose}
function create_if_block_1$5(ctx) {
	let button;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true, "aria-label": true });
			children(button).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "class", "modal-close is-large");
			attr_dev(button, "aria-label", "close");
			add_location(button, file$7, 47, 6, 1071);
			dispose = listen_dev(button, "click", /*close*/ ctx[6], false, false, false);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$5.name,
		type: "if",
		source: "(47:4) {#if showClose}",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let if_block_anchor;
	let current;
	let dispose;
	let if_block = /*active*/ ctx[0] && create_if_block$6(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			dispose = listen_dev(window, "keydown", /*keydown*/ ctx[7], false, false, false);
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*active*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block$6(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let { active = true } = $$props;
	let { animation = "scale" } = $$props;
	let { animProps = { start: 1.2 } } = $$props;
	let { size = "" } = $$props;
	let { showClose = true } = $$props;
	let { subComponent = null } = $$props;
	let { onBody = true } = $$props;
	let modal;

	onMount(() => {
		
	});

	function close() {
		$$invalidate(0, active = false);
	}

	function keydown(e) {
		if (active && isEscKey(e)) {
			close();
		}
	}

	const writable_props = [
		"active",
		"animation",
		"animProps",
		"size",
		"showClose",
		"subComponent",
		"onBody"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Modal> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	function div3_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			$$invalidate(4, modal = $$value);
		});
	}

	$$self.$set = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("animation" in $$props) $$invalidate(8, animation = $$props.animation);
		if ("animProps" in $$props) $$invalidate(1, animProps = $$props.animProps);
		if ("size" in $$props) $$invalidate(2, size = $$props.size);
		if ("showClose" in $$props) $$invalidate(3, showClose = $$props.showClose);
		if ("subComponent" in $$props) $$invalidate(9, subComponent = $$props.subComponent);
		if ("onBody" in $$props) $$invalidate(10, onBody = $$props.onBody);
		if ("$$scope" in $$props) $$invalidate(11, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return {
			active,
			animation,
			animProps,
			size,
			showClose,
			subComponent,
			onBody,
			modal,
			_animation
		};
	};

	$$self.$inject_state = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("animation" in $$props) $$invalidate(8, animation = $$props.animation);
		if ("animProps" in $$props) $$invalidate(1, animProps = $$props.animProps);
		if ("size" in $$props) $$invalidate(2, size = $$props.size);
		if ("showClose" in $$props) $$invalidate(3, showClose = $$props.showClose);
		if ("subComponent" in $$props) $$invalidate(9, subComponent = $$props.subComponent);
		if ("onBody" in $$props) $$invalidate(10, onBody = $$props.onBody);
		if ("modal" in $$props) $$invalidate(4, modal = $$props.modal);
		if ("_animation" in $$props) $$invalidate(5, _animation = $$props._animation);
	};

	let _animation;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*animation*/ 256) {
			$: $$invalidate(5, _animation = chooseAnimation(animation));
		}

		if ($$self.$$.dirty & /*modal, active, onBody*/ 1041) {
			$: {
				if (modal && active && onBody) {
					modal.parentNode.removeChild(modal);
					document.body.appendChild(modal);
				}
			}
		}
	};

	return [
		active,
		animProps,
		size,
		showClose,
		modal,
		_animation,
		close,
		keydown,
		animation,
		subComponent,
		onBody,
		$$scope,
		$$slots,
		div3_binding
	];
}

class Modal extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
			active: 0,
			animation: 8,
			animProps: 1,
			size: 2,
			showClose: 3,
			subComponent: 9,
			onBody: 10
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Modal",
			options,
			id: create_fragment$7.name
		});
	}

	get active() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get animation() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set animation(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get animProps() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set animProps(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get showClose() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showClose(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subComponent() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subComponent(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onBody() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onBody(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

Modal.open = open;

function open(props) {
  const modal = new Modal({
    target: document.body,
    props,
    intro: true
  });

  modal.close = () => modal.$destroy();

  return modal;
}

/* Library/Server/Web/Data/Sites/svelma/src/components/Notice.svelte generated by Svelte v3.16.7 */

const { console: console_1 } = globals;
const file$8 = "Library/Server/Web/Data/Sites/svelma/src/components/Notice.svelte";

// (137:0) {#if active}
function create_if_block$7(ctx) {
	let div_1;
	let div_1_class_value;
	let div_1_aria_hidden_value;
	let div_1_intro;
	let div_1_outro;
	let current;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

	const block = {
		c: function create() {
			div_1 = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div_1 = claim_element(nodes, "DIV", { class: true, "aria-hidden": true });
			var div_1_nodes = children(div_1);
			if (default_slot) default_slot.l(div_1_nodes);
			div_1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div_1, "class", div_1_class_value = "notice " + /*position*/ ctx[1]);
			attr_dev(div_1, "aria-hidden", div_1_aria_hidden_value = !/*active*/ ctx[0]);
			add_location(div_1, file$8, 137, 2, 6092);
			dispose = listen_dev(div_1, "outroend", /*remove*/ ctx[5], false, false, false);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div_1, anchor);

			if (default_slot) {
				default_slot.m(div_1, null);
			}

			/*div_1_binding*/ ctx[17](div_1);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot && default_slot.p && dirty & /*$$scope*/ 32768) {
				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[15], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, null));
			}

			if (!current || dirty & /*position*/ 2 && div_1_class_value !== (div_1_class_value = "notice " + /*position*/ ctx[1])) {
				attr_dev(div_1, "class", div_1_class_value);
			}

			if (!current || dirty & /*active*/ 1 && div_1_aria_hidden_value !== (div_1_aria_hidden_value = !/*active*/ ctx[0])) {
				attr_dev(div_1, "aria-hidden", div_1_aria_hidden_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);

			add_render_callback(() => {
				if (div_1_outro) div_1_outro.end(1);
				if (!div_1_intro) div_1_intro = create_in_transition(div_1, fly, { y: /*transitionY*/ ctx[4] });
				div_1_intro.start();
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			if (div_1_intro) div_1_intro.invalidate();

			div_1_outro = create_out_transition(div_1, fade, {
				duration: /*transitionOut*/ ctx[2] ? 400 : 0
			});

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div_1);
			if (default_slot) default_slot.d(detaching);
			/*div_1_binding*/ ctx[17](null);
			if (detaching && div_1_outro) div_1_outro.end();
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$7.name,
		type: "if",
		source: "(137:0) {#if active}",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*active*/ ctx[0] && create_if_block$7(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*active*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block$7(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function filterProps(props) {
	const { active, type, position, duration } = props;
	return { active, type, position, duration };
}

const notices = {};

function instance$8($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { active = true } = $$props;
	let { type = "is-dark" } = $$props;
	let { position = "is-top" } = $$props;
	let { duration = 2000 } = $$props;
	let { transitionOut = true } = $$props;
	let el;
	let parent;
	let timer;
	const div = () => document.createElement("div");

	function close() {
		$$invalidate(0, active = false);
	}

	function remove() {
		clearTimeout(timer);
		$$invalidate(0, active = false);
		dispatch("destroyed");
	}

	function setupContainers() {
		if (!notices.topLeft) {
			notices.topLeft = div();
			notices.topLeft.className = "notices is-top-left";
			document.body.appendChild(notices.topLeft);
		}

		if (!notices.top) {
			notices.top = div();
			notices.top.className = "notices is-top";
			document.body.appendChild(notices.top);
		}

		if (!notices.topRight) {
			notices.topRight = div();
			notices.topRight.className = "notices is-top-right";
			document.body.appendChild(notices.topRight);
		}

		if (!notices.bottomRight) {
			notices.bottomRight = div();
			notices.bottomRight.className = "notices is-bottom-right";
			document.body.appendChild(notices.bottomRight);
		}

		if (!notices.bottom) {
			notices.bottom = div();
			notices.bottom.className = "notices is-bottom";
			document.body.appendChild(notices.bottom);
		}

		if (!notices.bottomLeft) {
			notices.bottomLeft = div();
			notices.bottomLeft.className = "notices is-bottom-left";
			document.body.appendChild(notices.bottomLeft);
		}
	}

	function chooseParent() {
		let div,
			divName = position.replace("is-", "").replace(/-([a-z])/g, g => g[1].toUpperCase());

		console.log(divName);
		if (div = notices[divName]) div.insertAdjacentElement("afterbegin", el);
	}

	onMount(() => {
		setupContainers();
		chooseParent();

		timer = setTimeout(
			() => {
				close();
			},
			duration
		);
	});

	const writable_props = ["active", "type", "position", "duration", "transitionOut"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Notice> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	function div_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			$$invalidate(3, el = $$value);
		});
	}

	$$self.$set = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("type" in $$props) $$invalidate(6, type = $$props.type);
		if ("position" in $$props) $$invalidate(1, position = $$props.position);
		if ("duration" in $$props) $$invalidate(7, duration = $$props.duration);
		if ("transitionOut" in $$props) $$invalidate(2, transitionOut = $$props.transitionOut);
		if ("$$scope" in $$props) $$invalidate(15, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return {
			active,
			type,
			position,
			duration,
			transitionOut,
			el,
			parent,
			timer,
			transitionY
		};
	};

	$$self.$inject_state = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("type" in $$props) $$invalidate(6, type = $$props.type);
		if ("position" in $$props) $$invalidate(1, position = $$props.position);
		if ("duration" in $$props) $$invalidate(7, duration = $$props.duration);
		if ("transitionOut" in $$props) $$invalidate(2, transitionOut = $$props.transitionOut);
		if ("el" in $$props) $$invalidate(3, el = $$props.el);
		if ("parent" in $$props) parent = $$props.parent;
		if ("timer" in $$props) timer = $$props.timer;
		if ("transitionY" in $$props) $$invalidate(4, transitionY = $$props.transitionY);
	};

	let transitionY;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*position*/ 2) {
			$: $$invalidate(4, transitionY = ~position.indexOf("is-top") ? -200 : 200);
		}
	};

	return [
		active,
		position,
		transitionOut,
		el,
		transitionY,
		remove,
		type,
		duration,
		close,
		timer,
		dispatch,
		parent,
		div,
		setupContainers,
		chooseParent,
		$$scope,
		$$slots,
		div_1_binding
	];
}

class Notice extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$8, create_fragment$8, safe_not_equal, {
			active: 0,
			type: 6,
			position: 1,
			duration: 7,
			transitionOut: 2,
			close: 8
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Notice",
			options,
			id: create_fragment$8.name
		});
	}

	get active() {
		throw new Error("<Notice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<Notice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Notice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Notice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get position() {
		throw new Error("<Notice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set position(value) {
		throw new Error("<Notice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get duration() {
		throw new Error("<Notice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set duration(value) {
		throw new Error("<Notice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get transitionOut() {
		throw new Error("<Notice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set transitionOut(value) {
		throw new Error("<Notice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get close() {
		return this.$$.ctx[8];
	}

	set close(value) {
		throw new Error("<Notice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* Library/Server/Web/Data/Sites/svelma/src/components/Notification/Notification.svelte generated by Svelte v3.16.7 */
const file$9 = "Library/Server/Web/Data/Sites/svelma/src/components/Notification/Notification.svelte";

// (92:0) {#if active}
function create_if_block$8(ctx) {
	let article;
	let t0;
	let div1;
	let t1;
	let div0;
	let article_class_value;
	let article_transition;
	let current;
	let if_block0 = /*showClose*/ ctx[2] && create_if_block_2$4(ctx);
	let if_block1 = /*icon*/ ctx[3] && create_if_block_1$6(ctx);
	const default_slot_template = /*$$slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

	const block = {
		c: function create() {
			article = element("article");
			if (if_block0) if_block0.c();
			t0 = space();
			div1 = element("div");
			if (if_block1) if_block1.c();
			t1 = space();
			div0 = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			article = claim_element(nodes, "ARTICLE", { class: true });
			var article_nodes = children(article);
			if (if_block0) if_block0.l(article_nodes);
			t0 = claim_space(article_nodes);
			div1 = claim_element(article_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (if_block1) if_block1.l(div1_nodes);
			t1 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (default_slot) default_slot.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			article_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "media-content");
			add_location(div0, file$9, 102, 6, 3328);
			attr_dev(div1, "class", "media svelte-pee90k");
			add_location(div1, file$9, 96, 4, 3159);
			attr_dev(article, "class", article_class_value = "notification " + /*type*/ ctx[1] + " svelte-pee90k");
			add_location(article, file$9, 92, 2, 2988);
		},
		m: function mount(target, anchor) {
			insert_dev(target, article, anchor);
			if (if_block0) if_block0.m(article, null);
			append_dev(article, t0);
			append_dev(article, div1);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t1);
			append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*showClose*/ ctx[2]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$4(ctx);
					if_block0.c();
					if_block0.m(article, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*icon*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
					transition_in(if_block1, 1);
				} else {
					if_block1 = create_if_block_1$6(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (default_slot && default_slot.p && dirty & /*$$scope*/ 4096) {
				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[12], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null));
			}

			if (!current || dirty & /*type*/ 2 && article_class_value !== (article_class_value = "notification " + /*type*/ ctx[1] + " svelte-pee90k")) {
				attr_dev(article, "class", article_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);
			transition_in(default_slot, local);

			if (local) {
				add_render_callback(() => {
					if (!article_transition) article_transition = create_bidirectional_transition(article, fade, {}, true);
					article_transition.run(1);
				});
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(if_block1);
			transition_out(default_slot, local);

			if (local) {
				if (!article_transition) article_transition = create_bidirectional_transition(article, fade, {}, false);
				article_transition.run(0);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(article);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			if (detaching && article_transition) article_transition.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$8.name,
		type: "if",
		source: "(92:0) {#if active}",
		ctx
	});

	return block;
}

// (94:4) {#if showClose}
function create_if_block_2$4(ctx) {
	let button;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true, "aria-label": true });
			children(button).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "class", "delete");
			attr_dev(button, "aria-label", /*ariaCloseLabel*/ ctx[5]);
			add_location(button, file$9, 94, 6, 3074);
			dispose = listen_dev(button, "click", /*close*/ ctx[7], false, false, false);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*ariaCloseLabel*/ 32) {
				attr_dev(button, "aria-label", /*ariaCloseLabel*/ ctx[5]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$4.name,
		type: "if",
		source: "(94:4) {#if showClose}",
		ctx
	});

	return block;
}

// (98:6) {#if icon}
function create_if_block_1$6(ctx) {
	let div;
	let current;

	const icon_1 = new Icon({
			props: {
				pack: /*iconPack*/ ctx[4],
				icon: /*newIcon*/ ctx[6],
				size: "is-large"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(icon_1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(icon_1.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "media-left");
			add_location(div, file$9, 98, 8, 3204);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(icon_1, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_1_changes = {};
			if (dirty & /*iconPack*/ 16) icon_1_changes.pack = /*iconPack*/ ctx[4];
			if (dirty & /*newIcon*/ 64) icon_1_changes.icon = /*newIcon*/ ctx[6];
			icon_1.$set(icon_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(icon_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$6.name,
		type: "if",
		source: "(98:6) {#if icon}",
		ctx
	});

	return block;
}

function create_fragment$9(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*active*/ ctx[0] && create_if_block$8(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*active*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block$8(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	let { type = "" } = $$props;
	let { active = true } = $$props;
	let { showClose = true } = $$props;
	let { autoClose = false } = $$props;
	let { duration = 2000 } = $$props;
	let { icon = "" } = $$props;
	let { iconPack = "" } = $$props;
	let { ariaCloseLabel = "" } = $$props;
	const dispatch = createEventDispatcher();
	let newIcon = "";
	let timer;

	function close() {
		$$invalidate(0, active = false);
		if (timer) clearTimeout(timer);
		dispatch("close", active);
	}

	const writable_props = [
		"type",
		"active",
		"showClose",
		"autoClose",
		"duration",
		"icon",
		"iconPack",
		"ariaCloseLabel"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Notification> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ("type" in $$props) $$invalidate(1, type = $$props.type);
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("showClose" in $$props) $$invalidate(2, showClose = $$props.showClose);
		if ("autoClose" in $$props) $$invalidate(8, autoClose = $$props.autoClose);
		if ("duration" in $$props) $$invalidate(9, duration = $$props.duration);
		if ("icon" in $$props) $$invalidate(3, icon = $$props.icon);
		if ("iconPack" in $$props) $$invalidate(4, iconPack = $$props.iconPack);
		if ("ariaCloseLabel" in $$props) $$invalidate(5, ariaCloseLabel = $$props.ariaCloseLabel);
		if ("$$scope" in $$props) $$invalidate(12, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return {
			type,
			active,
			showClose,
			autoClose,
			duration,
			icon,
			iconPack,
			ariaCloseLabel,
			newIcon,
			timer
		};
	};

	$$self.$inject_state = $$props => {
		if ("type" in $$props) $$invalidate(1, type = $$props.type);
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("showClose" in $$props) $$invalidate(2, showClose = $$props.showClose);
		if ("autoClose" in $$props) $$invalidate(8, autoClose = $$props.autoClose);
		if ("duration" in $$props) $$invalidate(9, duration = $$props.duration);
		if ("icon" in $$props) $$invalidate(3, icon = $$props.icon);
		if ("iconPack" in $$props) $$invalidate(4, iconPack = $$props.iconPack);
		if ("ariaCloseLabel" in $$props) $$invalidate(5, ariaCloseLabel = $$props.ariaCloseLabel);
		if ("newIcon" in $$props) $$invalidate(6, newIcon = $$props.newIcon);
		if ("timer" in $$props) timer = $$props.timer;
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*icon, type*/ 10) {
			$: {
				if (icon === true) {
					$$invalidate(6, newIcon = typeToIcon(type));
				} else {
					$$invalidate(6, newIcon = icon);
				}
			}
		}

		if ($$self.$$.dirty & /*active, autoClose, duration*/ 769) {
			$: {
				if (active && autoClose) {
					timer = setTimeout(
						() => {
							if (active) close();
						},
						duration
					);
				}
			}
		}
	};

	return [
		active,
		type,
		showClose,
		icon,
		iconPack,
		ariaCloseLabel,
		newIcon,
		close,
		autoClose,
		duration,
		timer,
		dispatch,
		$$scope,
		$$slots
	];
}

class Notification extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$9, create_fragment$9, safe_not_equal, {
			type: 1,
			active: 0,
			showClose: 2,
			autoClose: 8,
			duration: 9,
			icon: 3,
			iconPack: 4,
			ariaCloseLabel: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Notification",
			options,
			id: create_fragment$9.name
		});
	}

	get type() {
		throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active() {
		throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get showClose() {
		throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showClose(value) {
		throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autoClose() {
		throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autoClose(value) {
		throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get duration() {
		throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set duration(value) {
		throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get icon() {
		throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set icon(value) {
		throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get iconPack() {
		throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set iconPack(value) {
		throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaCloseLabel() {
		throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaCloseLabel(value) {
		throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* Library/Server/Web/Data/Sites/svelma/src/components/Notification/NotificationNotice.svelte generated by Svelte v3.16.7 */

// (35:2) <Notification {...notificationProps}>
function create_default_slot_1(ctx) {
	let html_tag;

	const block = {
		c: function create() {
			this.h();
		},
		l: function claim(nodes) {
			this.h();
		},
		h: function hydrate() {
			html_tag = new HtmlTag(/*message*/ ctx[0], null);
		},
		m: function mount(target, anchor) {
			html_tag.m(target, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*message*/ 1) html_tag.p(/*message*/ ctx[0]);
		},
		d: function destroy(detaching) {
			if (detaching) html_tag.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(35:2) <Notification {...notificationProps}>",
		ctx
	});

	return block;
}

// (34:0) <Notice {...props} transitionOut={true}>
function create_default_slot(ctx) {
	let current;
	const notification_spread_levels = [/*notificationProps*/ ctx[2]];

	let notification_props = {
		$$slots: { default: [create_default_slot_1] },
		$$scope: { ctx }
	};

	for (let i = 0; i < notification_spread_levels.length; i += 1) {
		notification_props = assign(notification_props, notification_spread_levels[i]);
	}

	const notification = new Notification({
			props: notification_props,
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(notification.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(notification.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(notification, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const notification_changes = (dirty & /*notificationProps*/ 4)
			? get_spread_update(notification_spread_levels, [get_spread_object(/*notificationProps*/ ctx[2])])
			: {};

			if (dirty & /*$$scope, message*/ 129) {
				notification_changes.$$scope = { dirty, ctx };
			}

			notification.$set(notification_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(notification.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(notification.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(notification, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(34:0) <Notice {...props} transitionOut={true}>",
		ctx
	});

	return block;
}

function create_fragment$a(ctx) {
	let current;
	const notice_spread_levels = [/*props*/ ctx[1], { transitionOut: true }];

	let notice_props = {
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	for (let i = 0; i < notice_spread_levels.length; i += 1) {
		notice_props = assign(notice_props, notice_spread_levels[i]);
	}

	const notice = new Notice({ props: notice_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(notice.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(notice.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(notice, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const notice_changes = (dirty & /*props*/ 2)
			? get_spread_update(notice_spread_levels, [get_spread_object(/*props*/ ctx[1]), notice_spread_levels[1]])
			: {};

			if (dirty & /*$$scope, notificationProps, message*/ 133) {
				notice_changes.$$scope = { dirty, ctx };
			}

			notice.$set(notice_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(notice.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(notice.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(notice, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	let { message } = $$props;
	let { duration = 2000 } = $$props;
	let { position = "is-top-right" } = $$props;

	function removeNonNoficationProps(props) {
		const newProps = {};
		const blacklist = ["duration", "message", "position"];

		Object.keys(props).forEach(key => {
			if (!blacklist.includes(key)) newProps[key] = props[key];
		});

		return newProps;
	}

	$$self.$set = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("message" in $$new_props) $$invalidate(0, message = $$new_props.message);
		if ("duration" in $$new_props) $$invalidate(3, duration = $$new_props.duration);
		if ("position" in $$new_props) $$invalidate(4, position = $$new_props.position);
	};

	$$self.$capture_state = () => {
		return {
			message,
			duration,
			position,
			props,
			notificationProps
		};
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
		if ("message" in $$props) $$invalidate(0, message = $$new_props.message);
		if ("duration" in $$props) $$invalidate(3, duration = $$new_props.duration);
		if ("position" in $$props) $$invalidate(4, position = $$new_props.position);
		if ("props" in $$props) $$invalidate(1, props = $$new_props.props);
		if ("notificationProps" in $$props) $$invalidate(2, notificationProps = $$new_props.notificationProps);
	};

	let props;
	let notificationProps;

	$$self.$$.update = () => {
		$: $$invalidate(1, props = {
			...filterProps($$props),
			duration,
			position
		});

		$: $$invalidate(2, notificationProps = { ...removeNonNoficationProps($$props) });
	};

	$$props = exclude_internal_props($$props);
	return [message, props, notificationProps, duration, position];
}

class NotificationNotice extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$a, safe_not_equal, { message: 0, duration: 3, position: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "NotificationNotice",
			options,
			id: create_fragment$a.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (/*message*/ ctx[0] === undefined && !("message" in props)) {
			console.warn("<NotificationNotice> was created without expected prop 'message'");
		}
	}

	get message() {
		throw new Error("<NotificationNotice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set message(value) {
		throw new Error("<NotificationNotice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get duration() {
		throw new Error("<NotificationNotice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set duration(value) {
		throw new Error("<NotificationNotice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get position() {
		throw new Error("<NotificationNotice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set position(value) {
		throw new Error("<NotificationNotice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

Notification.create = create;

function create(props) {
  if (typeof props === 'string') props = { message: props };

  const notification = new NotificationNotice({
    target: document.body,
    props,
    intro: true,
  });

  notification.$on('destroyed', notification.$destroy);

  return notification
}

function is_date(obj) {
    return Object.prototype.toString.call(obj) === '[object Date]';
}

function get_interpolator(a, b) {
    if (a === b || a !== a)
        return () => a;
    const type = typeof a;
    if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
        throw new Error('Cannot interpolate values of different type');
    }
    if (Array.isArray(a)) {
        const arr = b.map((bi, i) => {
            return get_interpolator(a[i], bi);
        });
        return t => arr.map(fn => fn(t));
    }
    if (type === 'object') {
        if (!a || !b)
            throw new Error('Object cannot be null');
        if (is_date(a) && is_date(b)) {
            a = a.getTime();
            b = b.getTime();
            const delta = b - a;
            return t => new Date(a + t * delta);
        }
        const keys = Object.keys(b);
        const interpolators = {};
        keys.forEach(key => {
            interpolators[key] = get_interpolator(a[key], b[key]);
        });
        return t => {
            const result = {};
            keys.forEach(key => {
                result[key] = interpolators[key](t);
            });
            return result;
        };
    }
    if (type === 'number') {
        const delta = b - a;
        return t => a + t * delta;
    }
    throw new Error(`Cannot interpolate ${type} values`);
}
function tweened(value, defaults = {}) {
    const store = writable(value);
    let task;
    let target_value = value;
    function set(new_value, opts) {
        if (value == null) {
            store.set(value = new_value);
            return Promise.resolve();
        }
        target_value = new_value;
        let previous_task = task;
        let started = false;
        let { delay = 0, duration = 400, easing = identity, interpolate = get_interpolator } = assign(assign({}, defaults), opts);
        const start = now() + delay;
        let fn;
        task = loop(now => {
            if (now < start)
                return true;
            if (!started) {
                fn = interpolate(value, new_value);
                if (typeof duration === 'function')
                    duration = duration(value, new_value);
                started = true;
            }
            if (previous_task) {
                previous_task.abort();
                previous_task = null;
            }
            const elapsed = now - start;
            if (elapsed > duration) {
                store.set(value = new_value);
                return false;
            }
            // @ts-ignore
            store.set(value = fn(easing(elapsed / duration)));
            return true;
        });
        return task.promise;
    }
    return {
        set,
        update: (fn, opts) => set(fn(target_value, value), opts),
        subscribe: store.subscribe
    };
}

/* Library/Server/Web/Data/Sites/svelma/src/components/Progress.svelte generated by Svelte v3.16.7 */
const file$a = "Library/Server/Web/Data/Sites/svelma/src/components/Progress.svelte";

function create_fragment$b(ctx) {
	let progress;
	let t0;
	let t1;
	let progress_class_value;

	const block = {
		c: function create() {
			progress = element("progress");
			t0 = text(/*value*/ ctx[0]);
			t1 = text("%");
			this.h();
		},
		l: function claim(nodes) {
			progress = claim_element(nodes, "PROGRESS", { class: true, max: true });
			var progress_nodes = children(progress);
			t0 = claim_text(progress_nodes, /*value*/ ctx[0]);
			t1 = claim_text(progress_nodes, "%");
			progress_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(progress, "class", progress_class_value = "progress " + /*type*/ ctx[1]);
			attr_dev(progress, "max", /*max*/ ctx[2]);
			add_location(progress, file$a, 45, 0, 955);
		},
		m: function mount(target, anchor) {
			insert_dev(target, progress, anchor);
			append_dev(progress, t0);
			append_dev(progress, t1);
			/*progress_binding*/ ctx[7](progress);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*value*/ 1) set_data_dev(t0, /*value*/ ctx[0]);

			if (dirty & /*type*/ 2 && progress_class_value !== (progress_class_value = "progress " + /*type*/ ctx[1])) {
				attr_dev(progress, "class", progress_class_value);
			}

			if (dirty & /*max*/ 4) {
				attr_dev(progress, "max", /*max*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(progress);
			/*progress_binding*/ ctx[7](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props, $$invalidate) {
	let { value = null } = $$props;
	let { type = "" } = $$props;
	let { max = 100 } = $$props;
	let { duration = 400 } = $$props;
	let { easing = cubicOut } = $$props;
	let el;
	let newValue = tweened(value, { duration, easing });

	newValue.subscribe(val => {
		if (el && typeof (value !== undefined)) {
			el.setAttribute("value", get_store_value(newValue));
		}
	});

	const writable_props = ["value", "type", "max", "duration", "easing"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Progress> was created with unknown prop '${key}'`);
	});

	function progress_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			$$invalidate(3, el = $$value);
		});
	}

	$$self.$set = $$props => {
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("type" in $$props) $$invalidate(1, type = $$props.type);
		if ("max" in $$props) $$invalidate(2, max = $$props.max);
		if ("duration" in $$props) $$invalidate(4, duration = $$props.duration);
		if ("easing" in $$props) $$invalidate(5, easing = $$props.easing);
	};

	$$self.$capture_state = () => {
		return {
			value,
			type,
			max,
			duration,
			easing,
			el,
			newValue
		};
	};

	$$self.$inject_state = $$props => {
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("type" in $$props) $$invalidate(1, type = $$props.type);
		if ("max" in $$props) $$invalidate(2, max = $$props.max);
		if ("duration" in $$props) $$invalidate(4, duration = $$props.duration);
		if ("easing" in $$props) $$invalidate(5, easing = $$props.easing);
		if ("el" in $$props) $$invalidate(3, el = $$props.el);
		if ("newValue" in $$props) $$invalidate(6, newValue = $$props.newValue);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			$: newValue.set(value);
		}
	};

	return [value, type, max, el, duration, easing, newValue, progress_binding];
}

class Progress extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$b, create_fragment$b, safe_not_equal, {
			value: 0,
			type: 1,
			max: 2,
			duration: 4,
			easing: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Progress",
			options,
			id: create_fragment$b.name
		});
	}

	get value() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get duration() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set duration(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get easing() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set easing(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* Library/Server/Web/Data/Sites/svelma/src/components/Snackbar/Snackbar.svelte generated by Svelte v3.16.7 */

const { Error: Error_1$1 } = globals;
const file$b = "Library/Server/Web/Data/Sites/svelma/src/components/Snackbar/Snackbar.svelte";

// (97:4) {#if actionText}
function create_if_block$9(ctx) {
	let div;
	let button;
	let t;
	let button_class_value;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			button = element("button");
			t = text(/*actionText*/ ctx[5]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			button = claim_element(div_nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, /*actionText*/ ctx[5]);
			button_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "class", button_class_value = "button " + /*newType*/ ctx[7] + " svelte-jpep0r");
			add_location(button, file$b, 98, 8, 4943);
			attr_dev(div, "class", "action svelte-jpep0r");
			add_location(div, file$b, 97, 6, 4896);
			dispose = listen_dev(div, "click", /*action*/ ctx[8], false, false, false);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, button);
			append_dev(button, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*actionText*/ 32) set_data_dev(t, /*actionText*/ ctx[5]);

			if (dirty & /*newType*/ 128 && button_class_value !== (button_class_value = "button " + /*newType*/ ctx[7] + " svelte-jpep0r")) {
				attr_dev(button, "class", button_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$9.name,
		type: "if",
		source: "(97:4) {#if actionText}",
		ctx
	});

	return block;
}

// (91:0) <Notice { ...filterProps( { $$props, duration, position, type })} bind:this={notice} transitionOut={false}>
function create_default_slot$1(ctx) {
	let div1;
	let div0;
	let t;
	let div1_class_value;
	let if_block = /*actionText*/ ctx[5] && create_if_block$9(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			t = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true, role: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			div0_nodes.forEach(detach_dev);
			t = claim_space(div1_nodes);
			if (if_block) if_block.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "text svelte-jpep0r");
			add_location(div0, file$b, 92, 4, 4737);
			attr_dev(div1, "class", div1_class_value = "snackbar " + /*type*/ ctx[3] + " " + /*background*/ ctx[4] + " svelte-jpep0r");
			attr_dev(div1, "role", "alert");
			toggle_class(div1, "has-background-dark", !/*background*/ ctx[4]);
			add_location(div1, file$b, 91, 2, 4637);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			div0.innerHTML = /*message*/ ctx[0];
			append_dev(div1, t);
			if (if_block) if_block.m(div1, null);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*message*/ 1) div0.innerHTML = /*message*/ ctx[0];
			if (/*actionText*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$9(ctx);
					if_block.c();
					if_block.m(div1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*type, background*/ 24 && div1_class_value !== (div1_class_value = "snackbar " + /*type*/ ctx[3] + " " + /*background*/ ctx[4] + " svelte-jpep0r")) {
				attr_dev(div1, "class", div1_class_value);
			}

			if (dirty & /*type, background, background*/ 24) {
				toggle_class(div1, "has-background-dark", !/*background*/ ctx[4]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(91:0) <Notice { ...filterProps( { $$props, duration, position, type })} bind:this={notice} transitionOut={false}>",
		ctx
	});

	return block;
}

function create_fragment$c(ctx) {
	let current;

	const notice_1_spread_levels = [
		filterProps({
			$$props: /*$$props*/ ctx[9],
			duration: /*duration*/ ctx[1],
			position: /*position*/ ctx[2],
			type: /*type*/ ctx[3]
		}),
		{ transitionOut: false }
	];

	let notice_1_props = {
		$$slots: { default: [create_default_slot$1] },
		$$scope: { ctx }
	};

	for (let i = 0; i < notice_1_spread_levels.length; i += 1) {
		notice_1_props = assign(notice_1_props, notice_1_spread_levels[i]);
	}

	const notice_1 = new Notice({ props: notice_1_props, $$inline: true });
	/*notice_1_binding*/ ctx[11](notice_1);

	const block = {
		c: function create() {
			create_component(notice_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(notice_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(notice_1, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const notice_1_changes = (dirty & /*filterProps, $$props, duration, position, type*/ 526)
			? get_spread_update(notice_1_spread_levels, [
					get_spread_object(filterProps({
						$$props: /*$$props*/ ctx[9],
						duration: /*duration*/ ctx[1],
						position: /*position*/ ctx[2],
						type: /*type*/ ctx[3]
					})),
					notice_1_spread_levels[1]
				])
			: {};

			if (dirty & /*$$scope, type, background, actionText, newType, message*/ 4281) {
				notice_1_changes.$$scope = { dirty, ctx };
			}

			notice_1.$set(notice_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(notice_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(notice_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			/*notice_1_binding*/ ctx[11](null);
			destroy_component(notice_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$c($$self, $$props, $$invalidate) {
	let { message } = $$props;
	let { duration = 3500 } = $$props;
	let { position = "is-bottom-right" } = $$props;
	let { type = "is-primary" } = $$props;
	let { background = "" } = $$props;
	let { actionText = "OK" } = $$props;

	let { onAction = () => {
		
	} } = $$props;

	let notice;

	function action() {
		Promise.resolve(onAction()).then(() => notice.close());
	}

	onMount(() => {
		if (typeof onAction !== "function") throw new Error(`onAction ${onAction} is not a function`);
	});

	function notice_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			$$invalidate(6, notice = $$value);
		});
	}

	$$self.$set = $$new_props => {
		$$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("message" in $$new_props) $$invalidate(0, message = $$new_props.message);
		if ("duration" in $$new_props) $$invalidate(1, duration = $$new_props.duration);
		if ("position" in $$new_props) $$invalidate(2, position = $$new_props.position);
		if ("type" in $$new_props) $$invalidate(3, type = $$new_props.type);
		if ("background" in $$new_props) $$invalidate(4, background = $$new_props.background);
		if ("actionText" in $$new_props) $$invalidate(5, actionText = $$new_props.actionText);
		if ("onAction" in $$new_props) $$invalidate(10, onAction = $$new_props.onAction);
	};

	$$self.$capture_state = () => {
		return {
			message,
			duration,
			position,
			type,
			background,
			actionText,
			onAction,
			notice,
			newType
		};
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
		if ("message" in $$props) $$invalidate(0, message = $$new_props.message);
		if ("duration" in $$props) $$invalidate(1, duration = $$new_props.duration);
		if ("position" in $$props) $$invalidate(2, position = $$new_props.position);
		if ("type" in $$props) $$invalidate(3, type = $$new_props.type);
		if ("background" in $$props) $$invalidate(4, background = $$new_props.background);
		if ("actionText" in $$props) $$invalidate(5, actionText = $$new_props.actionText);
		if ("onAction" in $$props) $$invalidate(10, onAction = $$new_props.onAction);
		if ("notice" in $$props) $$invalidate(6, notice = $$new_props.notice);
		if ("newType" in $$props) $$invalidate(7, newType = $$new_props.newType);
	};

	let newType;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*type*/ 8) {
			$: $$invalidate(7, newType = type && type.replace(/^is-(.*)/, "has-text-$1"));
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		message,
		duration,
		position,
		type,
		background,
		actionText,
		notice,
		newType,
		action,
		$$props,
		onAction,
		notice_1_binding
	];
}

class Snackbar extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$c, create_fragment$c, safe_not_equal, {
			message: 0,
			duration: 1,
			position: 2,
			type: 3,
			background: 4,
			actionText: 5,
			onAction: 10
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Snackbar",
			options,
			id: create_fragment$c.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (/*message*/ ctx[0] === undefined && !("message" in props)) {
			console.warn("<Snackbar> was created without expected prop 'message'");
		}
	}

	get message() {
		throw new Error_1$1("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set message(value) {
		throw new Error_1$1("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get duration() {
		throw new Error_1$1("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set duration(value) {
		throw new Error_1$1("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get position() {
		throw new Error_1$1("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set position(value) {
		throw new Error_1$1("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error_1$1("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error_1$1("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get background() {
		throw new Error_1$1("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set background(value) {
		throw new Error_1$1("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get actionText() {
		throw new Error_1$1("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set actionText(value) {
		throw new Error_1$1("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onAction() {
		throw new Error_1$1("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onAction(value) {
		throw new Error_1$1("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function create$1(props) {

  if (typeof props === 'string') props = { message: props };

  const snackbar = new Snackbar({
    target: document.body,
    props,
    intro: true,
  });
  
  snackbar.$on('destroyed', snackbar.$destroy);
  
  return snackbar;
}

Snackbar.create = create$1;

/* Library/Server/Web/Data/Sites/svelma/src/components/Switch.svelte generated by Svelte v3.16.7 */

const file$c = "Library/Server/Web/Data/Sites/svelma/src/components/Switch.svelte";

function create_fragment$d(ctx) {
	let label_1;
	let input_1;
	let t0;
	let div;
	let div_class_value;
	let t1;
	let span;
	let label_1_class_value;
	let current;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	const block = {
		c: function create() {
			label_1 = element("label");
			input_1 = element("input");
			t0 = space();
			div = element("div");
			t1 = space();
			span = element("span");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			label_1 = claim_element(nodes, "LABEL", { ref: true, class: true });
			var label_1_nodes = children(label_1);
			input_1 = claim_element(label_1_nodes, "INPUT", { type: true, class: true });
			t0 = claim_space(label_1_nodes);
			div = claim_element(label_1_nodes, "DIV", { class: true });
			children(div).forEach(detach_dev);
			t1 = claim_space(label_1_nodes);
			span = claim_element(label_1_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			if (default_slot) default_slot.l(span_nodes);
			span_nodes.forEach(detach_dev);
			label_1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input_1, "type", "checkbox");
			attr_dev(input_1, "class", "svelte-16lix3s");
			add_location(input_1, file$c, 124, 2, 7168);
			attr_dev(div, "class", div_class_value = "check " + /*newBackground*/ ctx[4] + " svelte-16lix3s");
			add_location(div, file$c, 126, 2, 7246);
			attr_dev(span, "class", "control-label svelte-16lix3s");
			add_location(span, file$c, 128, 2, 7291);
			attr_dev(label_1, "ref", "label");
			attr_dev(label_1, "class", label_1_class_value = "switch " + /*size*/ ctx[1] + " svelte-16lix3s");
			add_location(label_1, file$c, 123, 0, 7106);

			dispose = [
				listen_dev(input_1, "change", /*input_1_change_handler*/ ctx[11]),
				listen_dev(input_1, "input", /*input_handler*/ ctx[9], false, false, false),
				listen_dev(input_1, "click", /*click_handler*/ ctx[10], false, false, false)
			];
		},
		m: function mount(target, anchor) {
			insert_dev(target, label_1, anchor);
			append_dev(label_1, input_1);
			input_1.checked = /*checked*/ ctx[0];
			/*input_1_binding*/ ctx[12](input_1);
			append_dev(label_1, t0);
			append_dev(label_1, div);
			append_dev(label_1, t1);
			append_dev(label_1, span);

			if (default_slot) {
				default_slot.m(span, null);
			}

			/*label_1_binding*/ ctx[13](label_1);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*checked*/ 1) {
				input_1.checked = /*checked*/ ctx[0];
			}

			if (!current || dirty & /*newBackground*/ 16 && div_class_value !== (div_class_value = "check " + /*newBackground*/ ctx[4] + " svelte-16lix3s")) {
				attr_dev(div, "class", div_class_value);
			}

			if (default_slot && default_slot.p && dirty & /*$$scope*/ 128) {
				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[7], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null));
			}

			if (!current || dirty & /*size*/ 2 && label_1_class_value !== (label_1_class_value = "switch " + /*size*/ ctx[1] + " svelte-16lix3s")) {
				attr_dev(label_1, "class", label_1_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label_1);
			/*input_1_binding*/ ctx[12](null);
			if (default_slot) default_slot.d(detaching);
			/*label_1_binding*/ ctx[13](null);
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$d($$self, $$props, $$invalidate) {
	let { checked = false } = $$props;
	let { type = "is-primary" } = $$props;
	let { size = "" } = $$props;
	let { disabled = false } = $$props;
	let label;
	let input;
	const writable_props = ["checked", "type", "size", "disabled"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Switch> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	function input_handler(event) {
		bubble($$self, event);
	}

	function click_handler(event) {
		bubble($$self, event);
	}

	function input_1_change_handler() {
		checked = this.checked;
		$$invalidate(0, checked);
	}

	function input_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			$$invalidate(3, input = $$value);
		});
	}

	function label_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			$$invalidate(2, label = $$value);
		});
	}

	$$self.$set = $$props => {
		if ("checked" in $$props) $$invalidate(0, checked = $$props.checked);
		if ("type" in $$props) $$invalidate(5, type = $$props.type);
		if ("size" in $$props) $$invalidate(1, size = $$props.size);
		if ("disabled" in $$props) $$invalidate(6, disabled = $$props.disabled);
		if ("$$scope" in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return {
			checked,
			type,
			size,
			disabled,
			label,
			input,
			newBackground
		};
	};

	$$self.$inject_state = $$props => {
		if ("checked" in $$props) $$invalidate(0, checked = $$props.checked);
		if ("type" in $$props) $$invalidate(5, type = $$props.type);
		if ("size" in $$props) $$invalidate(1, size = $$props.size);
		if ("disabled" in $$props) $$invalidate(6, disabled = $$props.disabled);
		if ("label" in $$props) $$invalidate(2, label = $$props.label);
		if ("input" in $$props) $$invalidate(3, input = $$props.input);
		if ("newBackground" in $$props) $$invalidate(4, newBackground = $$props.newBackground);
	};

	let newBackground;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*type*/ 32) {
			$: $$invalidate(4, newBackground = type && type.replace(/^is-(.*)/, "has-background-$1") || "");
		}

		if ($$self.$$.dirty & /*input, disabled, label*/ 76) {
			$: {
				if (input) {
					if (disabled) {
						label.setAttribute("disabled", "disabled");
						input.setAttribute("disabled", "disabled");
					} else {
						label.removeAttribute("disabled");
						input.removeAttribute("disabled");
					}
				}
			}
		}
	};

	return [
		checked,
		size,
		label,
		input,
		newBackground,
		type,
		disabled,
		$$scope,
		$$slots,
		input_handler,
		click_handler,
		input_1_change_handler,
		input_1_binding,
		label_1_binding
	];
}

class Switch extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$d, create_fragment$d, safe_not_equal, {
			checked: 0,
			type: 5,
			size: 1,
			disabled: 6
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Switch",
			options,
			id: create_fragment$d.name
		});
	}

	get checked() {
		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* Library/Server/Web/Data/Sites/svelma/src/components/Tabs/Tabs.svelte generated by Svelte v3.16.7 */
const file$d = "Library/Server/Web/Data/Sites/svelma/src/components/Tabs/Tabs.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[15] = list[i];
	child_ctx[17] = i;
	return child_ctx;
}

// (94:12) {#if tab.icon}
function create_if_block$a(ctx) {
	let current;

	const icon = new Icon({
			props: {
				pack: /*tab*/ ctx[15].iconPack,
				icon: /*tab*/ ctx[15].icon
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*$tabs*/ 32) icon_changes.pack = /*tab*/ ctx[15].iconPack;
			if (dirty & /*$tabs*/ 32) icon_changes.icon = /*tab*/ ctx[15].icon;
			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$a.name,
		type: "if",
		source: "(94:12) {#if tab.icon}",
		ctx
	});

	return block;
}

// (91:6) {#each $tabs as tab, index}
function create_each_block(ctx) {
	let li;
	let a;
	let t0;
	let span;
	let t1_value = /*tab*/ ctx[15].label + "";
	let t1;
	let t2;
	let current;
	let dispose;
	let if_block = /*tab*/ ctx[15].icon && create_if_block$a(ctx);

	function click_handler(...args) {
		return /*click_handler*/ ctx[14](/*index*/ ctx[17], ...args);
	}

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			if (if_block) if_block.c();
			t0 = space();
			span = element("span");
			t1 = text(t1_value);
			t2 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", {});
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true });
			var a_nodes = children(a);
			if (if_block) if_block.l(a_nodes);
			t0 = claim_space(a_nodes);
			span = claim_element(a_nodes, "SPAN", {});
			var span_nodes = children(span);
			t1 = claim_text(span_nodes, t1_value);
			span_nodes.forEach(detach_dev);
			a_nodes.forEach(detach_dev);
			t2 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(span, file$d, 97, 12, 3267);
			attr_dev(a, "href", "");
			add_location(a, file$d, 92, 10, 3092);
			toggle_class(li, "is-active", /*index*/ ctx[17] === /*activeTab*/ ctx[4]);
			add_location(li, file$d, 91, 8, 3039);
			dispose = listen_dev(a, "click", prevent_default(click_handler), false, true, false);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			if (if_block) if_block.m(a, null);
			append_dev(a, t0);
			append_dev(a, span);
			append_dev(span, t1);
			append_dev(li, t2);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*tab*/ ctx[15].icon) {
				if (if_block) {
					if_block.p(ctx, dirty);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block$a(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(a, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if ((!current || dirty & /*$tabs*/ 32) && t1_value !== (t1_value = /*tab*/ ctx[15].label + "")) set_data_dev(t1, t1_value);

			if (dirty & /*activeTab*/ 16) {
				toggle_class(li, "is-active", /*index*/ ctx[17] === /*activeTab*/ ctx[4]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (if_block) if_block.d();
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(91:6) {#each $tabs as tab, index}",
		ctx
	});

	return block;
}

function create_fragment$e(ctx) {
	let div;
	let nav;
	let ul;
	let nav_class_value;
	let t;
	let section;
	let current;
	let each_value = /*$tabs*/ ctx[5];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const default_slot_template = /*$$slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

	const block = {
		c: function create() {
			div = element("div");
			nav = element("nav");
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			section = element("section");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			nav = claim_element(div_nodes, "NAV", { class: true });
			var nav_nodes = children(nav);
			ul = claim_element(nav_nodes, "UL", {});
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t = claim_space(div_nodes);
			section = claim_element(div_nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			if (default_slot) default_slot.l(section_nodes);
			section_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(ul, file$d, 89, 4, 2992);
			attr_dev(nav, "class", nav_class_value = "tabs " + /*size*/ ctx[0] + " " + /*position*/ ctx[1] + " " + /*style*/ ctx[2] + " svelte-1wu1l6d");
			add_location(nav, file$d, 88, 2, 2943);
			attr_dev(section, "class", "tab-content svelte-1wu1l6d");
			add_location(section, file$d, 103, 2, 3356);
			attr_dev(div, "class", "tabs-wrapper svelte-1wu1l6d");
			toggle_class(div, "is-fullwidth", /*expanded*/ ctx[3]);
			add_location(div, file$d, 87, 0, 2884);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, nav);
			append_dev(nav, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			append_dev(div, t);
			append_dev(div, section);

			if (default_slot) {
				default_slot.m(section, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*activeTab, changeTab, $tabs*/ 176) {
				each_value = /*$tabs*/ ctx[5];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (!current || dirty & /*size, position, style*/ 7 && nav_class_value !== (nav_class_value = "tabs " + /*size*/ ctx[0] + " " + /*position*/ ctx[1] + " " + /*style*/ ctx[2] + " svelte-1wu1l6d")) {
				attr_dev(nav, "class", nav_class_value);
			}

			if (default_slot && default_slot.p && dirty & /*$$scope*/ 4096) {
				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[12], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null));
			}

			if (dirty & /*expanded*/ 8) {
				toggle_class(div, "is-fullwidth", /*expanded*/ ctx[3]);
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$e($$self, $$props, $$invalidate) {
	let $tabs;
	const dispatch = createEventDispatcher();
	let { value = 0 } = $$props;
	let { size = "" } = $$props;
	let { position = "" } = $$props;
	let { style = "" } = $$props;
	let { expanded = false } = $$props;
	let activeTab = 0;
	const tabs = writable([]);
	validate_store(tabs, "tabs");
	component_subscribe($$self, tabs, value => $$invalidate(5, $tabs = value));
	const tabConfig = { activeTab, tabs };
	setContext("tabs", tabConfig);

	const unsubscribe = tabs.subscribe(ts => {
		if (ts.length > 0 && ts.length > value - 1) {
			ts.forEach(t => t.deactivate());
			if (ts[value]) ts[value].activate();
		}
	});

	function changeTab(tabNumber) {
		const ts = get_store_value(tabs);
		if (ts[activeTab]) ts[activeTab].deactivate();
		if (ts[tabNumber]) ts[tabNumber].activate();
		$$invalidate(4, activeTab = tabConfig.activeTab = tabNumber);
		dispatch("activeTabChanged", tabNumber);
	}

	onMount(() => {
		changeTab(activeTab);
	});

	onDestroy(() => {
		unsubscribe();
	});

	const writable_props = ["value", "size", "position", "style", "expanded"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tabs> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	const click_handler = index => changeTab(index);

	$$self.$set = $$props => {
		if ("value" in $$props) $$invalidate(8, value = $$props.value);
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("position" in $$props) $$invalidate(1, position = $$props.position);
		if ("style" in $$props) $$invalidate(2, style = $$props.style);
		if ("expanded" in $$props) $$invalidate(3, expanded = $$props.expanded);
		if ("$$scope" in $$props) $$invalidate(12, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return {
			value,
			size,
			position,
			style,
			expanded,
			activeTab,
			$tabs
		};
	};

	$$self.$inject_state = $$props => {
		if ("value" in $$props) $$invalidate(8, value = $$props.value);
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("position" in $$props) $$invalidate(1, position = $$props.position);
		if ("style" in $$props) $$invalidate(2, style = $$props.style);
		if ("expanded" in $$props) $$invalidate(3, expanded = $$props.expanded);
		if ("activeTab" in $$props) $$invalidate(4, activeTab = $$props.activeTab);
		if ("$tabs" in $$props) tabs.set($tabs = $$props.$tabs);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 256) {
			$: changeTab(value);
		}
	};

	return [
		size,
		position,
		style,
		expanded,
		activeTab,
		$tabs,
		tabs,
		changeTab,
		value,
		tabConfig,
		dispatch,
		unsubscribe,
		$$scope,
		$$slots,
		click_handler
	];
}

class Tabs extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$e, create_fragment$e, safe_not_equal, {
			value: 8,
			size: 0,
			position: 1,
			style: 2,
			expanded: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Tabs",
			options,
			id: create_fragment$e.name
		});
	}

	get value() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get position() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set position(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get expanded() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set expanded(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* Library/Server/Web/Data/Sites/svelma/src/components/Tabs/Tab.svelte generated by Svelte v3.16.7 */
const file$e = "Library/Server/Web/Data/Sites/svelma/src/components/Tabs/Tab.svelte";

const get_default_slot_changes$1 = dirty => ({
	label: dirty & /*label*/ 1,
	iconPack: dirty & /*iconPack*/ 4,
	icon: dirty & /*icon*/ 2
});

const get_default_slot_context$1 = ctx => ({
	label: /*label*/ ctx[0],
	iconPack: /*iconPack*/ ctx[2],
	icon: /*icon*/ ctx[1]
});

function create_fragment$f(ctx) {
	let div;
	let div_class_value;
	let div_aria_hidden_value;
	let current;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], get_default_slot_context$1);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true, "aria-hidden": true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", div_class_value = "tab " + /*direction*/ ctx[5] + " svelte-yuw9hu");
			attr_dev(div, "aria-hidden", div_aria_hidden_value = !/*active*/ ctx[3]);
			toggle_class(div, "is-active", /*active*/ ctx[3]);
			add_location(div, file$e, 100, 0, 2829);
			dispose = listen_dev(div, "transitionend", /*transitionend*/ ctx[6], false, false, false);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[15](div);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot && default_slot.p && dirty & /*$$scope, label, iconPack, icon*/ 8199) {
				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[13], get_default_slot_context$1), get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, get_default_slot_changes$1));
			}

			if (!current || dirty & /*direction*/ 32 && div_class_value !== (div_class_value = "tab " + /*direction*/ ctx[5] + " svelte-yuw9hu")) {
				attr_dev(div, "class", div_class_value);
			}

			if (!current || dirty & /*active*/ 8 && div_aria_hidden_value !== (div_aria_hidden_value = !/*active*/ ctx[3])) {
				attr_dev(div, "aria-hidden", div_aria_hidden_value);
			}

			if (dirty & /*direction, active*/ 40) {
				toggle_class(div, "is-active", /*active*/ ctx[3]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[15](null);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$f($$self, $$props, $$invalidate) {
	let { label } = $$props;
	let { icon = "" } = $$props;
	let { iconPack = "" } = $$props;
	let active = false;
	let el;
	let index;
	let starting = false;
	let direction = "";
	let isIn = false;
	const tabConfig = getContext("tabs");

	async function changeTab({ from, to }) {
		if (from === to) return;

		if (from === index) {
			$$invalidate(5, direction = index < to ? "left" : "right");
		} else if (to === index) {
			$$invalidate(3, active = true);
			$$invalidate(5, direction = index > from ? "right" : "left");
		} else $$invalidate(5, direction = "");
	}

	function updateIndex() {
		if (!el) return;
		index = Array.prototype.indexOf.call(el.parentNode.children, el);
	}

	async function transitionend(event) {
		$$invalidate(3, active = index === tabConfig.activeTab);
		await tick();
		$$invalidate(5, direction = "");
	}

	tabConfig.tabs.subscribe(tabs => {
		updateIndex();
	});

	onMount(() => {
		updateIndex();

		tabConfig.tabs.update(tabs => [
			...tabs,
			{
				index,
				label,
				icon,
				iconPack,
				activate: () => $$invalidate(3, active = true),
				deactivate: () => $$invalidate(3, active = false),
				changeTab
			}
		]);
	});

	beforeUpdate(async () => {
		if (index === tabConfig.activeTab && direction) {
			await tick();

			setTimeout(() => {
				$$invalidate(5, direction = "");
			});
		}
	});

	const writable_props = ["label", "icon", "iconPack"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tab> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			$$invalidate(4, el = $$value);
		});
	}

	$$self.$set = $$props => {
		if ("label" in $$props) $$invalidate(0, label = $$props.label);
		if ("icon" in $$props) $$invalidate(1, icon = $$props.icon);
		if ("iconPack" in $$props) $$invalidate(2, iconPack = $$props.iconPack);
		if ("$$scope" in $$props) $$invalidate(13, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return {
			label,
			icon,
			iconPack,
			active,
			el,
			index,
			starting,
			direction,
			isIn
		};
	};

	$$self.$inject_state = $$props => {
		if ("label" in $$props) $$invalidate(0, label = $$props.label);
		if ("icon" in $$props) $$invalidate(1, icon = $$props.icon);
		if ("iconPack" in $$props) $$invalidate(2, iconPack = $$props.iconPack);
		if ("active" in $$props) $$invalidate(3, active = $$props.active);
		if ("el" in $$props) $$invalidate(4, el = $$props.el);
		if ("index" in $$props) index = $$props.index;
		if ("starting" in $$props) starting = $$props.starting;
		if ("direction" in $$props) $$invalidate(5, direction = $$props.direction);
		if ("isIn" in $$props) isIn = $$props.isIn;
	};

	return [
		label,
		icon,
		iconPack,
		active,
		el,
		direction,
		transitionend,
		changeTab,
		index,
		starting,
		isIn,
		tabConfig,
		updateIndex,
		$$scope,
		$$slots,
		div_binding
	];
}

class Tab extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$f, create_fragment$f, safe_not_equal, {
			label: 0,
			icon: 1,
			iconPack: 2,
			changeTab: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Tab",
			options,
			id: create_fragment$f.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (/*label*/ ctx[0] === undefined && !("label" in props)) {
			console.warn("<Tab> was created without expected prop 'label'");
		}
	}

	get label() {
		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get icon() {
		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set icon(value) {
		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get iconPack() {
		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set iconPack(value) {
		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get changeTab() {
		return this.$$.ctx[7];
	}

	set changeTab(value) {
		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* Library/Server/Web/Data/Sites/svelma/src/components/Toast/Toast.svelte generated by Svelte v3.16.7 */
const file$f = "Library/Server/Web/Data/Sites/svelma/src/components/Toast/Toast.svelte";

// (50:0) <Notice {...filterProps($$props)}>
function create_default_slot$2(ctx) {
	let div1;
	let div0;
	let div1_class_value;

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true, role: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "text");
			add_location(div0, file$f, 51, 4, 2365);
			attr_dev(div1, "class", div1_class_value = "toast " + /*type*/ ctx[1] + " " + /*newBackground*/ ctx[2] + " svelte-u20xz4");
			attr_dev(div1, "role", "alert");
			add_location(div1, file$f, 50, 2, 2305);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			div0.innerHTML = /*message*/ ctx[0];
		},
		p: function update(ctx, dirty) {
			if (dirty & /*message*/ 1) div0.innerHTML = /*message*/ ctx[0];
			if (dirty & /*type, newBackground*/ 6 && div1_class_value !== (div1_class_value = "toast " + /*type*/ ctx[1] + " " + /*newBackground*/ ctx[2] + " svelte-u20xz4")) {
				attr_dev(div1, "class", div1_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(50:0) <Notice {...filterProps($$props)}>",
		ctx
	});

	return block;
}

function create_fragment$g(ctx) {
	let current;
	const notice_spread_levels = [filterProps(/*$$props*/ ctx[3])];

	let notice_props = {
		$$slots: { default: [create_default_slot$2] },
		$$scope: { ctx }
	};

	for (let i = 0; i < notice_spread_levels.length; i += 1) {
		notice_props = assign(notice_props, notice_spread_levels[i]);
	}

	const notice = new Notice({ props: notice_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(notice.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(notice.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(notice, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const notice_changes = (dirty & /*filterProps, $$props*/ 8)
			? get_spread_update(notice_spread_levels, [get_spread_object(filterProps(/*$$props*/ ctx[3]))])
			: {};

			if (dirty & /*$$scope, type, newBackground, message*/ 39) {
				notice_changes.$$scope = { dirty, ctx };
			}

			notice.$set(notice_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(notice.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(notice.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(notice, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$g($$self, $$props, $$invalidate) {
	let { message } = $$props;
	let { type = "is-dark" } = $$props;
	let { background = "" } = $$props;

	$$self.$set = $$new_props => {
		$$invalidate(3, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("message" in $$new_props) $$invalidate(0, message = $$new_props.message);
		if ("type" in $$new_props) $$invalidate(1, type = $$new_props.type);
		if ("background" in $$new_props) $$invalidate(4, background = $$new_props.background);
	};

	$$self.$capture_state = () => {
		return { message, type, background, newBackground };
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(3, $$props = assign(assign({}, $$props), $$new_props));
		if ("message" in $$props) $$invalidate(0, message = $$new_props.message);
		if ("type" in $$props) $$invalidate(1, type = $$new_props.type);
		if ("background" in $$props) $$invalidate(4, background = $$new_props.background);
		if ("newBackground" in $$props) $$invalidate(2, newBackground = $$new_props.newBackground);
	};

	let newBackground;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*background, type*/ 18) {
			$: $$invalidate(2, newBackground = background || type.replace(/^is-(.*)/, "has-background-$1"));
		}
	};

	$$props = exclude_internal_props($$props);
	return [message, type, newBackground, $$props, background];
}

class Toast extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$g, create_fragment$g, safe_not_equal, { message: 0, type: 1, background: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Toast",
			options,
			id: create_fragment$g.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (/*message*/ ctx[0] === undefined && !("message" in props)) {
			console.warn("<Toast> was created without expected prop 'message'");
		}
	}

	get message() {
		throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set message(value) {
		throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get background() {
		throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set background(value) {
		throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function create$2(props) {
  if (typeof props === 'string') props = { message: props };
  
  const toast = new Toast({
    target: document.body,
    props,
    intro: true,
  });
  
  toast.$on('destroyed', toast.$destroy);
  
  return toast;
}

Toast.create = create$2;

// import './scss/main.scss'

const Svelma = {
  Button,
  Collapse,
  Dialog,
  Icon,
  Input,
  Field,
  Message,
  Modal,
  Notification,
  Progress,
  Snackbar,
  Switch,
  Tabs,
  Tab,
  Toast,
};

export { Svelma as a, writable as b, Message as c, Button as d, Notification as e, Collapse as f, Progress as g, Snackbar as h, Icon as i, Toast as j, Dialog as k, Switch as l, Field as m, Input as n, Modal as o, Tabs as p, Tab as q, fade as r, slide as s };
