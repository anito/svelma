import { c as SvelteComponentDev, d as init, b as safe_not_equal, e as dispatch_dev, u as onMount, C as create_component, G as space, D as claim_component, H as claim_space, E as mount_component, n as insert_dev, A as transition_in, y as transition_out, F as destroy_component, i as detach_dev, w as empty, f as element, R as text, g as claim_element, h as children, S as claim_text, j as attr_dev, k as add_location, o as append_dev, T as set_data_dev, m as listen_dev, a9 as destroy_each, U as run_all, a as noop } from './chunk.0f951886.js';
import './chunk.b9034416.js';
import './chunk.0a41e55b.js';
import { a as DocHeader } from './chunk.45862366.js';
import './chunk.162a27e3.js';
import { a as Example } from './chunk.09bae8d1.js';

/* src/routes/bulma/table.svelte generated by Svelte v3.16.7 */
const file = "src/routes/bulma/table.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	return child_ctx;
}

// (111:8) {:else}
function create_else_block(ctx) {
	let if_block_anchor;
	let if_block = !/*loading*/ ctx[0] && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (!/*loading*/ ctx[0]) {
				if (!if_block) {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(111:8) {:else}",
		ctx
	});

	return block;
}

// (112:10) {#if !loading}
function create_if_block(ctx) {
	let tr;
	let td;
	let section;
	let div;
	let p0;
	let i;
	let t0;
	let p1;
	let t1;
	let t2;

	const block = {
		c: function create() {
			tr = element("tr");
			td = element("td");
			section = element("section");
			div = element("div");
			p0 = element("p");
			i = element("i");
			t0 = space();
			p1 = element("p");
			t1 = text("No data");
			t2 = space();
			this.h();
		},
		l: function claim(nodes) {
			tr = claim_element(nodes, "TR", {});
			var tr_nodes = children(tr);
			td = claim_element(tr_nodes, "TD", { colspan: true });
			var td_nodes = children(td);
			section = claim_element(td_nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			div = claim_element(section_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			p0 = claim_element(div_nodes, "P", {});
			var p0_nodes = children(p0);
			i = claim_element(p0_nodes, "I", { class: true });
			children(i).forEach(detach_dev);
			p0_nodes.forEach(detach_dev);
			t0 = claim_space(div_nodes);
			p1 = claim_element(div_nodes, "P", {});
			var p1_nodes = children(p1);
			t1 = claim_text(p1_nodes, "No data");
			p1_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			td_nodes.forEach(detach_dev);
			t2 = claim_space(tr_nodes);
			tr_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(i, "class", "far fa-3x fa-frown");
			add_location(i, file, 116, 23, 3089);
			add_location(p0, file, 116, 20, 3086);
			add_location(p1, file, 117, 20, 3148);
			attr_dev(div, "class", "content has-text-grey has-text-centered");
			add_location(div, file, 115, 18, 3012);
			attr_dev(section, "class", "section");
			add_location(section, file, 114, 16, 2968);
			attr_dev(td, "colspan", "5");
			add_location(td, file, 113, 14, 2935);
			add_location(tr, file, 112, 12, 2916);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);
			append_dev(tr, td);
			append_dev(td, section);
			append_dev(section, div);
			append_dev(div, p0);
			append_dev(p0, i);
			append_dev(div, t0);
			append_dev(div, p1);
			append_dev(p1, t1);
			append_dev(tr, t2);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(112:10) {#if !loading}",
		ctx
	});

	return block;
}

// (103:8) {#each users as user}
function create_each_block(ctx) {
	let tr;
	let td0;
	let figure;
	let img;
	let img_src_value;
	let t0;
	let td1;
	let t1_value = /*titleize*/ ctx[2](/*user*/ ctx[5].name.first) + "";
	let t1;
	let t2;
	let td2;
	let t3_value = /*titleize*/ ctx[2](/*user*/ ctx[5].name.last) + "";
	let t3;
	let t4;
	let td3;
	let t5_value = /*titleize*/ ctx[2](/*user*/ ctx[5].location.city) + "";
	let t5;
	let t6;
	let td4;
	let t7_value = /*titleize*/ ctx[2](/*user*/ ctx[5].location.state) + "";
	let t7;
	let t8;

	const block = {
		c: function create() {
			tr = element("tr");
			td0 = element("td");
			figure = element("figure");
			img = element("img");
			t0 = space();
			td1 = element("td");
			t1 = text(t1_value);
			t2 = space();
			td2 = element("td");
			t3 = text(t3_value);
			t4 = space();
			td3 = element("td");
			t5 = text(t5_value);
			t6 = space();
			td4 = element("td");
			t7 = text(t7_value);
			t8 = space();
			this.h();
		},
		l: function claim(nodes) {
			tr = claim_element(nodes, "TR", {});
			var tr_nodes = children(tr);
			td0 = claim_element(tr_nodes, "TD", {});
			var td0_nodes = children(td0);
			figure = claim_element(td0_nodes, "FIGURE", { class: true });
			var figure_nodes = children(figure);
			img = claim_element(figure_nodes, "IMG", { class: true, src: true, alt: true });
			figure_nodes.forEach(detach_dev);
			td0_nodes.forEach(detach_dev);
			t0 = claim_space(tr_nodes);
			td1 = claim_element(tr_nodes, "TD", {});
			var td1_nodes = children(td1);
			t1 = claim_text(td1_nodes, t1_value);
			td1_nodes.forEach(detach_dev);
			t2 = claim_space(tr_nodes);
			td2 = claim_element(tr_nodes, "TD", {});
			var td2_nodes = children(td2);
			t3 = claim_text(td2_nodes, t3_value);
			td2_nodes.forEach(detach_dev);
			t4 = claim_space(tr_nodes);
			td3 = claim_element(tr_nodes, "TD", {});
			var td3_nodes = children(td3);
			t5 = claim_text(td3_nodes, t5_value);
			td3_nodes.forEach(detach_dev);
			t6 = claim_space(tr_nodes);
			td4 = claim_element(tr_nodes, "TD", {});
			var td4_nodes = children(td4);
			t7 = claim_text(td4_nodes, t7_value);
			td4_nodes.forEach(detach_dev);
			t8 = claim_space(tr_nodes);
			tr_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(img, "class", "is-rounded");
			if (img.src !== (img_src_value = /*user*/ ctx[5].picture.thumbnail)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "");
			add_location(img, file, 104, 38, 2568);
			attr_dev(figure, "class", "image");
			add_location(figure, file, 104, 16, 2546);
			add_location(td0, file, 104, 12, 2542);
			add_location(td1, file, 105, 12, 2657);
			add_location(td2, file, 106, 12, 2706);
			add_location(td3, file, 107, 12, 2754);
			add_location(td4, file, 108, 12, 2806);
			add_location(tr, file, 103, 10, 2525);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);
			append_dev(tr, td0);
			append_dev(td0, figure);
			append_dev(figure, img);
			append_dev(tr, t0);
			append_dev(tr, td1);
			append_dev(td1, t1);
			append_dev(tr, t2);
			append_dev(tr, td2);
			append_dev(td2, t3);
			append_dev(tr, t4);
			append_dev(tr, td3);
			append_dev(td3, t5);
			append_dev(tr, t6);
			append_dev(tr, td4);
			append_dev(td4, t7);
			append_dev(tr, t8);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*users*/ 2 && img.src !== (img_src_value = /*user*/ ctx[5].picture.thumbnail)) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty & /*users*/ 2 && t1_value !== (t1_value = /*titleize*/ ctx[2](/*user*/ ctx[5].name.first) + "")) set_data_dev(t1, t1_value);
			if (dirty & /*users*/ 2 && t3_value !== (t3_value = /*titleize*/ ctx[2](/*user*/ ctx[5].name.last) + "")) set_data_dev(t3, t3_value);
			if (dirty & /*users*/ 2 && t5_value !== (t5_value = /*titleize*/ ctx[2](/*user*/ ctx[5].location.city) + "")) set_data_dev(t5, t5_value);
			if (dirty & /*users*/ 2 && t7_value !== (t7_value = /*titleize*/ ctx[2](/*user*/ ctx[5].location.state) + "")) set_data_dev(t7, t7_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(103:8) {#each users as user}",
		ctx
	});

	return block;
}

// (85:2) <div slot="preview">
function create_preview_slot(ctx) {
	let div;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let br0;
	let t4;
	let br1;
	let t5;
	let table;
	let thead;
	let tr;
	let th0;
	let t6;
	let th1;
	let t7;
	let t8;
	let th2;
	let t9;
	let t10;
	let th3;
	let t11;
	let t12;
	let th4;
	let t13;
	let t14;
	let tbody;
	let dispose;
	let each_value = /*users*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	let each_1_else = null;

	if (!each_value.length) {
		each_1_else = create_else_block(ctx);
		each_1_else.c();
	}

	const block = {
		c: function create() {
			div = element("div");
			button0 = element("button");
			t0 = text("Update");
			t1 = space();
			button1 = element("button");
			t2 = text("No Data");
			t3 = space();
			br0 = element("br");
			t4 = space();
			br1 = element("br");
			t5 = space();
			table = element("table");
			thead = element("thead");
			tr = element("tr");
			th0 = element("th");
			t6 = space();
			th1 = element("th");
			t7 = text("First Name");
			t8 = space();
			th2 = element("th");
			t9 = text("Last Name");
			t10 = space();
			th3 = element("th");
			t11 = text("City");
			t12 = space();
			th4 = element("th");
			t13 = text("State");
			t14 = space();
			tbody = element("tbody");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true });
			var div_nodes = children(div);
			button0 = claim_element(div_nodes, "BUTTON", { class: true });
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "Update");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			button1 = claim_element(div_nodes, "BUTTON", { class: true });
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "No Data");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(div_nodes);
			br0 = claim_element(div_nodes, "BR", {});
			t4 = claim_space(div_nodes);
			br1 = claim_element(div_nodes, "BR", {});
			t5 = claim_space(div_nodes);
			table = claim_element(div_nodes, "TABLE", { class: true });
			var table_nodes = children(table);
			thead = claim_element(table_nodes, "THEAD", {});
			var thead_nodes = children(thead);
			tr = claim_element(thead_nodes, "TR", {});
			var tr_nodes = children(tr);
			th0 = claim_element(tr_nodes, "TH", {});
			children(th0).forEach(detach_dev);
			t6 = claim_space(tr_nodes);
			th1 = claim_element(tr_nodes, "TH", {});
			var th1_nodes = children(th1);
			t7 = claim_text(th1_nodes, "First Name");
			th1_nodes.forEach(detach_dev);
			t8 = claim_space(tr_nodes);
			th2 = claim_element(tr_nodes, "TH", {});
			var th2_nodes = children(th2);
			t9 = claim_text(th2_nodes, "Last Name");
			th2_nodes.forEach(detach_dev);
			t10 = claim_space(tr_nodes);
			th3 = claim_element(tr_nodes, "TH", {});
			var th3_nodes = children(th3);
			t11 = claim_text(th3_nodes, "City");
			th3_nodes.forEach(detach_dev);
			t12 = claim_space(tr_nodes);
			th4 = claim_element(tr_nodes, "TH", {});
			var th4_nodes = children(th4);
			t13 = claim_text(th4_nodes, "State");
			th4_nodes.forEach(detach_dev);
			tr_nodes.forEach(detach_dev);
			thead_nodes.forEach(detach_dev);
			t14 = claim_space(table_nodes);
			tbody = claim_element(table_nodes, "TBODY", {});
			var tbody_nodes = children(tbody);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(tbody_nodes);
			}

			tbody_nodes.forEach(detach_dev);
			table_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button0, "class", "button is-primary");
			add_location(button0, file, 85, 4, 2077);
			attr_dev(button1, "class", "button is-primary");
			add_location(button1, file, 86, 4, 2149);
			add_location(br0, file, 88, 4, 2233);
			add_location(br1, file, 89, 4, 2242);
			add_location(th0, file, 94, 10, 2324);
			add_location(th1, file, 95, 10, 2344);
			add_location(th2, file, 96, 10, 2374);
			add_location(th3, file, 97, 10, 2403);
			add_location(th4, file, 98, 10, 2427);
			add_location(tr, file, 93, 8, 2309);
			add_location(thead, file, 92, 6, 2293);
			add_location(tbody, file, 101, 6, 2477);
			attr_dev(table, "class", "table is-fullwidth");
			add_location(table, file, 91, 4, 2252);
			attr_dev(div, "slot", "preview");
			add_location(div, file, 84, 2, 2052);

			dispose = [
				listen_dev(button0, "click", /*update*/ ctx[3], false, false, false),
				listen_dev(button1, "click", /*click_handler*/ ctx[4], false, false, false)
			];
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, button0);
			append_dev(button0, t0);
			append_dev(div, t1);
			append_dev(div, button1);
			append_dev(button1, t2);
			append_dev(div, t3);
			append_dev(div, br0);
			append_dev(div, t4);
			append_dev(div, br1);
			append_dev(div, t5);
			append_dev(div, table);
			append_dev(table, thead);
			append_dev(thead, tr);
			append_dev(tr, th0);
			append_dev(tr, t6);
			append_dev(tr, th1);
			append_dev(th1, t7);
			append_dev(tr, t8);
			append_dev(tr, th2);
			append_dev(th2, t9);
			append_dev(tr, t10);
			append_dev(tr, th3);
			append_dev(th3, t11);
			append_dev(tr, t12);
			append_dev(tr, th4);
			append_dev(th4, t13);
			append_dev(table, t14);
			append_dev(table, tbody);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tbody, null);
			}

			if (each_1_else) {
				each_1_else.m(tbody, null);
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*titleize, users, loading*/ 7) {
				each_value = /*users*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tbody, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (!each_value.length && each_1_else) {
				each_1_else.p(ctx, dirty);
			} else if (!each_value.length) {
				each_1_else = create_else_block(ctx);
				each_1_else.c();
				each_1_else.m(tbody, null);
			} else if (each_1_else) {
				each_1_else.d(1);
				each_1_else = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
			if (each_1_else) each_1_else.d();
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_preview_slot.name,
		type: "slot",
		source: "(85:2) <div slot=\\\"preview\\\">",
		ctx
	});

	return block;
}

// (26:0) <Example code={`<script>   let loading = false   let users = []    const titleize = s => s.replace(/^([a-z])/, (_, r) => r.toUpperCase())    async function update() {     loading = true      users = []     users = (await (await fetch('https://randomuser.me/api/?results=10')).json()).results      loading = false   }    onMount(() => update()) </script>  <button class="button is-primary" on:click={update}>Update</button> <button class="button is-primary" on:click={() => users = []}>No Data</button>  <br> <br>  <table class="table is-fullwidth">   <thead>     <tr>       <th></th>       <th>First Name</th>       <th>Last Name</th>       <th>City</th>       <th>State</th>     </tr>   </thead>   <tbody>     {#each users as user}       <tr>         <td><figure class="image"><img class="is-rounded" src="{user.picture.thumbnail}" alt=""></figure></td>         <td>{titleize(user.name.first)}</td>         <td>{titleize(user.name.last)}</td>         <td>{titleize(user.location.city)}</td>         <td>{titleize(user.location.state)}</td>       </tr>     {:else}       {#if !loading}         <tr>           <td colspan="5">             <section class="section">               <div class="content has-text-grey has-text-centered">                 <p><i class="far fa-3x fa-frown"></i></p>                 <p>No data</p>               </div>             </section>           </td>         </tr>       {/if}     {/each}   </tbody> </table>`}>
function create_default_slot(ctx) {
	const block = {
		c: noop,
		l: noop,
		m: noop,
		p: noop,
		d: noop
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(26:0) <Example code={`<script>   let loading = false   let users = []    const titleize = s => s.replace(/^([a-z])/, (_, r) => r.toUpperCase())    async function update() {     loading = true      users = []     users = (await (await fetch('https://randomuser.me/api/?results=10')).json()).results      loading = false   }    onMount(() => update()) </script>  <button class=\\\"button is-primary\\\" on:click={update}>Update</button> <button class=\\\"button is-primary\\\" on:click={() => users = []}>No Data</button>  <br> <br>  <table class=\\\"table is-fullwidth\\\">   <thead>     <tr>       <th></th>       <th>First Name</th>       <th>Last Name</th>       <th>City</th>       <th>State</th>     </tr>   </thead>   <tbody>     {#each users as user}       <tr>         <td><figure class=\\\"image\\\"><img class=\\\"is-rounded\\\" src=\\\"{user.picture.thumbnail}\\\" alt=\\\"\\\"></figure></td>         <td>{titleize(user.name.first)}</td>         <td>{titleize(user.name.last)}</td>         <td>{titleize(user.location.city)}</td>         <td>{titleize(user.location.state)}</td>       </tr>     {:else}       {#if !loading}         <tr>           <td colspan=\\\"5\\\">             <section class=\\\"section\\\">               <div class=\\\"content has-text-grey has-text-centered\\\">                 <p><i class=\\\"far fa-3x fa-frown\\\"></i></p>                 <p>No data</p>               </div>             </section>           </td>         </tr>       {/if}     {/each}   </tbody> </table>`}>",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let t;
	let current;

	const docheader = new DocHeader({
			props: {
				title: "Tables",
				subtitle: "Pretty HTML tables"
			},
			$$inline: true
		});

	const example = new Example({
			props: {
				code: `<script>
  let loading = false
  let users = []

  const titleize = s => s.replace(/^([a-z])/, (_, r) => r.toUpperCase())

  async function update() {
    loading = true

    users = []
    users = (await (await fetch('https://randomuser.me/api/?results=10')).json()).results

    loading = false
  }

  onMount(() => update())
</script>

<button class="button is-primary" on:click={update}>Update</button>
<button class="button is-primary" on:click={() => users = []}>No Data</button>

<br>
<br>

<table class="table is-fullwidth">
  <thead>
    <tr>
      <th></th>
      <th>First Name</th>
      <th>Last Name</th>
      <th>City</th>
      <th>State</th>
    </tr>
  </thead>
  <tbody>
    {#each users as user}
      <tr>
        <td><figure class="image"><img class="is-rounded" src="{user.picture.thumbnail}" alt=""></figure></td>
        <td>{titleize(user.name.first)}</td>
        <td>{titleize(user.name.last)}</td>
        <td>{titleize(user.location.city)}</td>
        <td>{titleize(user.location.state)}</td>
      </tr>
    {:else}
      {#if !loading}
        <tr>
          <td colspan="5">
            <section class="section">
              <div class="content has-text-grey has-text-centered">
                <p><i class="far fa-3x fa-frown"></i></p>
                <p>No data</p>
              </div>
            </section>
          </td>
        </tr>
      {/if}
    {/each}
  </tbody>
</table>`,
				$$slots: {
					default: [create_default_slot],
					preview: [create_preview_slot]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(docheader.$$.fragment);
			t = space();
			create_component(example.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(docheader.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(example.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(docheader, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(example, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const example_changes = {};

			if (dirty & /*$$scope, users, loading*/ 259) {
				example_changes.$$scope = { dirty, ctx };
			}

			example.$set(example_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(docheader.$$.fragment, local);
			transition_in(example.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(docheader.$$.fragment, local);
			transition_out(example.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(docheader, detaching);
			if (detaching) detach_dev(t);
			destroy_component(example, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let loading = false;
	let users = [];
	const titleize = s => s.replace(/^([a-z])/, (_, r) => r.toUpperCase());

	async function update() {
		$$invalidate(0, loading = true);
		$$invalidate(1, users = []);
		$$invalidate(1, users = (await (await fetch("https://randomuser.me/api/?results=10")).json()).results);
		$$invalidate(0, loading = false);
	}

	onMount(() => update());
	const click_handler = () => $$invalidate(1, users = []);

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ("loading" in $$props) $$invalidate(0, loading = $$props.loading);
		if ("users" in $$props) $$invalidate(1, users = $$props.users);
	};

	return [loading, users, titleize, update, click_handler];
}

class Table extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Table",
			options,
			id: create_fragment.name
		});
	}
}

export default Table;
