import { c as SvelteComponentDev, d as init, b as safe_not_equal, e as dispatch_dev, f as element, G as space, R as text, g as claim_element, H as claim_space, h as children, S as claim_text, i as detach_dev, j as attr_dev, k as add_location, o as append_dev, n as insert_dev, T as set_data_dev, a as noop } from './chunk.0f951886.js';

/* src/components/DocHeader.svelte generated by Svelte v3.16.7 */

const file = "src/components/DocHeader.svelte";

function create_fragment(ctx) {
	let meta0;
	let meta1;
	let meta2;
	let t0;
	let header;
	let h1;
	let t1;
	let t2;
	let h2;
	let t3;

	const block = {
		c: function create() {
			meta0 = element("meta");
			meta1 = element("meta");
			meta2 = element("meta");
			t0 = space();
			header = element("header");
			h1 = element("h1");
			t1 = text(/*title*/ ctx[0]);
			t2 = space();
			h2 = element("h2");
			t3 = text(/*subtitle*/ ctx[1]);
			this.h();
		},
		l: function claim(nodes) {
			meta0 = claim_element(nodes, "META", { property: true, content: true });
			meta1 = claim_element(nodes, "META", { property: true, content: true });
			meta2 = claim_element(nodes, "META", { property: true, content: true });
			t0 = claim_space(nodes);
			header = claim_element(nodes, "HEADER", { class: true });
			var header_nodes = children(header);
			h1 = claim_element(header_nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t1 = claim_text(h1_nodes, /*title*/ ctx[0]);
			h1_nodes.forEach(detach_dev);
			t2 = claim_space(header_nodes);
			h2 = claim_element(header_nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t3 = claim_text(h2_nodes, /*subtitle*/ ctx[1]);
			h2_nodes.forEach(detach_dev);
			header_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(meta0, "property", "og:type");
			attr_dev(meta0, "content", "article");
			add_location(meta0, file, 8, 2, 114);
			attr_dev(meta1, "property", "og:title");
			attr_dev(meta1, "content", /*newTitle*/ ctx[2]);
			add_location(meta1, file, 9, 2, 162);
			attr_dev(meta2, "property", "og:description");
			attr_dev(meta2, "content", /*subtitle*/ ctx[1]);
			add_location(meta2, file, 10, 2, 212);
			attr_dev(h1, "class", "title");
			add_location(h1, file, 15, 2, 344);
			attr_dev(h2, "class", "subtitle");
			add_location(h2, file, 16, 2, 377);
			attr_dev(header, "class", "header");
			add_location(header, file, 14, 0, 318);
		},
		m: function mount(target, anchor) {
			append_dev(document.head, meta0);
			append_dev(document.head, meta1);
			append_dev(document.head, meta2);
			insert_dev(target, t0, anchor);
			insert_dev(target, header, anchor);
			append_dev(header, h1);
			append_dev(h1, t1);
			append_dev(header, t2);
			append_dev(header, h2);
			append_dev(h2, t3);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*newTitle*/ 4) {
				attr_dev(meta1, "content", /*newTitle*/ ctx[2]);
			}

			if (dirty & /*subtitle*/ 2) {
				attr_dev(meta2, "content", /*subtitle*/ ctx[1]);
			}

			if (dirty & /*title*/ 1) set_data_dev(t1, /*title*/ ctx[0]);
			if (dirty & /*subtitle*/ 2) set_data_dev(t3, /*subtitle*/ ctx[1]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			detach_dev(meta0);
			detach_dev(meta1);
			detach_dev(meta2);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(header);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { title } = $$props;
	let { subtitle } = $$props;
	const writable_props = ["title", "subtitle"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DocHeader> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("subtitle" in $$props) $$invalidate(1, subtitle = $$props.subtitle);
	};

	$$self.$capture_state = () => {
		return { title, subtitle, newTitle };
	};

	$$self.$inject_state = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("subtitle" in $$props) $$invalidate(1, subtitle = $$props.subtitle);
		if ("newTitle" in $$props) $$invalidate(2, newTitle = $$props.newTitle);
	};

	let newTitle;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*title*/ 1) {
			$: $$invalidate(2, newTitle = `${title} | Svelma`);
		}
	};

	return [title, subtitle, newTitle];
}

class DocHeader extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { title: 0, subtitle: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DocHeader",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (/*title*/ ctx[0] === undefined && !("title" in props)) {
			console.warn("<DocHeader> was created without expected prop 'title'");
		}

		if (/*subtitle*/ ctx[1] === undefined && !("subtitle" in props)) {
			console.warn("<DocHeader> was created without expected prop 'subtitle'");
		}
	}

	get title() {
		throw new Error("<DocHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<DocHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subtitle() {
		throw new Error("<DocHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subtitle(value) {
		throw new Error("<DocHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { DocHeader as a };
