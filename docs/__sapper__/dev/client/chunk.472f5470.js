import { c as SvelteComponentDev, d as init, b as safe_not_equal, e as dispatch_dev, G as space, f as element, R as text, H as claim_space, g as claim_element, h as children, S as claim_text, i as detach_dev, k as add_location, j as attr_dev, n as insert_dev, o as append_dev, a9 as destroy_each, w as empty, a1 as HtmlTag, T as set_data_dev, a as noop } from './chunk.0f951886.js';

/* src/components/JSDoc.svelte generated by Svelte v3.16.7 */

const file = "src/components/JSDoc.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[2] = list[i];
	return child_ctx;
}

// (15:0) {#if jsdoc}
function create_if_block(ctx) {
	let t0;
	let section;
	let t1;
	let div;
	let table;
	let thead;
	let tr;
	let th0;
	let t2;
	let t3;
	let th1;
	let t4;
	let t5;
	let th2;
	let t6;
	let t7;
	let th3;
	let t8;
	let t9;
	let th4;
	let t10;
	let t11;
	let tbody;
	let if_block0 = /*showHeader*/ ctx[1] && create_if_block_3(ctx);
	let if_block1 = /*showHeader*/ ctx[1] && create_if_block_2(ctx);
	let each_value = /*jsdoc*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t0 = space();
			section = element("section");
			if (if_block1) if_block1.c();
			t1 = space();
			div = element("div");
			table = element("table");
			thead = element("thead");
			tr = element("tr");
			th0 = element("th");
			t2 = text("Name");
			t3 = space();
			th1 = element("th");
			t4 = text("Description");
			t5 = space();
			th2 = element("th");
			t6 = text("Type");
			t7 = space();
			th3 = element("th");
			t8 = text("Values");
			t9 = space();
			th4 = element("th");
			t10 = text("Default");
			t11 = space();
			tbody = element("tbody");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			if (if_block0) if_block0.l(nodes);
			t0 = claim_space(nodes);
			section = claim_element(nodes, "SECTION", {});
			var section_nodes = children(section);
			if (if_block1) if_block1.l(section_nodes);
			t1 = claim_space(section_nodes);
			div = claim_element(section_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			table = claim_element(div_nodes, "TABLE", { class: true });
			var table_nodes = children(table);
			thead = claim_element(table_nodes, "THEAD", {});
			var thead_nodes = children(thead);
			tr = claim_element(thead_nodes, "TR", {});
			var tr_nodes = children(tr);
			th0 = claim_element(tr_nodes, "TH", {});
			var th0_nodes = children(th0);
			t2 = claim_text(th0_nodes, "Name");
			th0_nodes.forEach(detach_dev);
			t3 = claim_space(tr_nodes);
			th1 = claim_element(tr_nodes, "TH", {});
			var th1_nodes = children(th1);
			t4 = claim_text(th1_nodes, "Description");
			th1_nodes.forEach(detach_dev);
			t5 = claim_space(tr_nodes);
			th2 = claim_element(tr_nodes, "TH", {});
			var th2_nodes = children(th2);
			t6 = claim_text(th2_nodes, "Type");
			th2_nodes.forEach(detach_dev);
			t7 = claim_space(tr_nodes);
			th3 = claim_element(tr_nodes, "TH", {});
			var th3_nodes = children(th3);
			t8 = claim_text(th3_nodes, "Values");
			th3_nodes.forEach(detach_dev);
			t9 = claim_space(tr_nodes);
			th4 = claim_element(tr_nodes, "TH", {});
			var th4_nodes = children(th4);
			t10 = claim_text(th4_nodes, "Default");
			th4_nodes.forEach(detach_dev);
			tr_nodes.forEach(detach_dev);
			thead_nodes.forEach(detach_dev);
			t11 = claim_space(table_nodes);
			tbody = claim_element(table_nodes, "TBODY", {});
			var tbody_nodes = children(tbody);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(tbody_nodes);
			}

			tbody_nodes.forEach(detach_dev);
			table_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(th0, file, 24, 12, 860);
			add_location(th1, file, 25, 12, 886);
			add_location(th2, file, 26, 12, 919);
			add_location(th3, file, 27, 12, 945);
			add_location(th4, file, 28, 12, 973);
			add_location(tr, file, 23, 10, 843);
			add_location(thead, file, 22, 8, 825);
			add_location(tbody, file, 31, 8, 1031);
			attr_dev(table, "class", "table is-fullwidth");
			add_location(table, file, 21, 6, 782);
			attr_dev(div, "class", "table-wrapper svelte-2ae2jn");
			add_location(div, file, 20, 4, 748);
			add_location(section, file, 17, 2, 676);
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, section, anchor);
			if (if_block1) if_block1.m(section, null);
			append_dev(section, t1);
			append_dev(section, div);
			append_dev(div, table);
			append_dev(table, thead);
			append_dev(thead, tr);
			append_dev(tr, th0);
			append_dev(th0, t2);
			append_dev(tr, t3);
			append_dev(tr, th1);
			append_dev(th1, t4);
			append_dev(tr, t5);
			append_dev(tr, th2);
			append_dev(th2, t6);
			append_dev(tr, t7);
			append_dev(tr, th3);
			append_dev(th3, t8);
			append_dev(tr, t9);
			append_dev(tr, th4);
			append_dev(th4, t10);
			append_dev(table, t11);
			append_dev(table, tbody);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tbody, null);
			}
		},
		p: function update(ctx, dirty) {
			if (/*showHeader*/ ctx[1]) {
				if (!if_block0) {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*showHeader*/ ctx[1]) {
				if (!if_block1) {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					if_block1.m(section, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*jsdoc*/ 1) {
				each_value = /*jsdoc*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tbody, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(section);
			if (if_block1) if_block1.d();
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(15:0) {#if jsdoc}",
		ctx
	});

	return block;
}

// (16:2) {#if showHeader}
function create_if_block_3(ctx) {
	let hr;

	const block = {
		c: function create() {
			hr = element("hr");
			this.h();
		},
		l: function claim(nodes) {
			hr = claim_element(nodes, "HR", { class: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(hr, "class", "is-medium");
			add_location(hr, file, 15, 18, 643);
		},
		m: function mount(target, anchor) {
			insert_dev(target, hr, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(hr);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(16:2) {#if showHeader}",
		ctx
	});

	return block;
}

// (19:4) {#if showHeader}
function create_if_block_2(ctx) {
	let h2;
	let t;

	const block = {
		c: function create() {
			h2 = element("h2");
			t = text("API");
			this.h();
		},
		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t = claim_text(h2_nodes, "API");
			h2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h2, "class", "title is-4");
			add_location(h2, file, 18, 20, 706);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			append_dev(h2, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(19:4) {#if showHeader}",
		ctx
	});

	return block;
}

// (39:39) {#if doc.optional}
function create_if_block_1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(", optional");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, ", optional");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(39:39) {#if doc.optional}",
		ctx
	});

	return block;
}

// (33:10) {#each jsdoc as doc}
function create_each_block(ctx) {
	let tr;
	let td0;
	let code;
	let t0_value = /*doc*/ ctx[2].name + "";
	let t0;
	let t1;
	let td1;
	let html_tag;
	let raw0_value = /*doc*/ ctx[2].description + "";
	let html_anchor;
	let t2;
	let td2;
	let t3_value = (/*doc*/ ctx[2].type || []).join(", ") + "";
	let t3;
	let t4;
	let td3;
	let raw1_value = (/*doc*/ ctx[2].values || "&mdash;") + "";
	let t5;
	let td4;
	let raw2_value = ("defaultvalue" in /*doc*/ ctx[2] && `<code>${/*doc*/ ctx[2].defaultvalue}</code>` || "&mdash;") + "";
	let t6;
	let if_block = /*doc*/ ctx[2].optional && create_if_block_1(ctx);

	const block = {
		c: function create() {
			tr = element("tr");
			td0 = element("td");
			code = element("code");
			t0 = text(t0_value);
			t1 = space();
			td1 = element("td");
			html_anchor = empty();
			if (if_block) if_block.c();
			t2 = space();
			td2 = element("td");
			t3 = text(t3_value);
			t4 = space();
			td3 = element("td");
			t5 = space();
			td4 = element("td");
			t6 = space();
			this.h();
		},
		l: function claim(nodes) {
			tr = claim_element(nodes, "TR", {});
			var tr_nodes = children(tr);
			td0 = claim_element(tr_nodes, "TD", {});
			var td0_nodes = children(td0);
			code = claim_element(td0_nodes, "CODE", {});
			var code_nodes = children(code);
			t0 = claim_text(code_nodes, t0_value);
			code_nodes.forEach(detach_dev);
			td0_nodes.forEach(detach_dev);
			t1 = claim_space(tr_nodes);
			td1 = claim_element(tr_nodes, "TD", {});
			var td1_nodes = children(td1);
			html_anchor = empty();
			if (if_block) if_block.l(td1_nodes);
			td1_nodes.forEach(detach_dev);
			t2 = claim_space(tr_nodes);
			td2 = claim_element(tr_nodes, "TD", {});
			var td2_nodes = children(td2);
			t3 = claim_text(td2_nodes, t3_value);
			td2_nodes.forEach(detach_dev);
			t4 = claim_space(tr_nodes);
			td3 = claim_element(tr_nodes, "TD", {});
			var td3_nodes = children(td3);
			td3_nodes.forEach(detach_dev);
			t5 = claim_space(tr_nodes);
			td4 = claim_element(tr_nodes, "TD", {});
			var td4_nodes = children(td4);
			td4_nodes.forEach(detach_dev);
			t6 = claim_space(tr_nodes);
			tr_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(code, file, 35, 16, 1122);
			add_location(td0, file, 34, 14, 1101);
			html_tag = new HtmlTag(raw0_value, html_anchor);
			add_location(td1, file, 37, 14, 1180);
			add_location(td2, file, 40, 14, 1292);
			add_location(td3, file, 41, 14, 1345);
			add_location(td4, file, 44, 14, 1432);
			add_location(tr, file, 33, 12, 1082);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);
			append_dev(tr, td0);
			append_dev(td0, code);
			append_dev(code, t0);
			append_dev(tr, t1);
			append_dev(tr, td1);
			html_tag.m(td1);
			append_dev(td1, html_anchor);
			if (if_block) if_block.m(td1, null);
			append_dev(tr, t2);
			append_dev(tr, td2);
			append_dev(td2, t3);
			append_dev(tr, t4);
			append_dev(tr, td3);
			td3.innerHTML = raw1_value;
			append_dev(tr, t5);
			append_dev(tr, td4);
			td4.innerHTML = raw2_value;
			append_dev(tr, t6);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*jsdoc*/ 1 && t0_value !== (t0_value = /*doc*/ ctx[2].name + "")) set_data_dev(t0, t0_value);
			if (dirty & /*jsdoc*/ 1 && raw0_value !== (raw0_value = /*doc*/ ctx[2].description + "")) html_tag.p(raw0_value);

			if (/*doc*/ ctx[2].optional) {
				if (!if_block) {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(td1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*jsdoc*/ 1 && t3_value !== (t3_value = (/*doc*/ ctx[2].type || []).join(", ") + "")) set_data_dev(t3, t3_value);
			if (dirty & /*jsdoc*/ 1 && raw1_value !== (raw1_value = (/*doc*/ ctx[2].values || "&mdash;") + "")) td3.innerHTML = raw1_value;			if (dirty & /*jsdoc*/ 1 && raw2_value !== (raw2_value = ("defaultvalue" in /*doc*/ ctx[2] && `<code>${/*doc*/ ctx[2].defaultvalue}</code>` || "&mdash;") + "")) td4.innerHTML = raw2_value;		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(33:10) {#each jsdoc as doc}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let if_block_anchor;
	let if_block = /*jsdoc*/ ctx[0] && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (/*jsdoc*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { jsdoc } = $$props;
	let { showHeader = true } = $$props;
	const writable_props = ["jsdoc", "showHeader"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<JSDoc> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ("jsdoc" in $$props) $$invalidate(0, jsdoc = $$props.jsdoc);
		if ("showHeader" in $$props) $$invalidate(1, showHeader = $$props.showHeader);
	};

	$$self.$capture_state = () => {
		return { jsdoc, showHeader };
	};

	$$self.$inject_state = $$props => {
		if ("jsdoc" in $$props) $$invalidate(0, jsdoc = $$props.jsdoc);
		if ("showHeader" in $$props) $$invalidate(1, showHeader = $$props.showHeader);
	};

	return [jsdoc, showHeader];
}

class JSDoc extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { jsdoc: 0, showHeader: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "JSDoc",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (/*jsdoc*/ ctx[0] === undefined && !("jsdoc" in props)) {
			console.warn("<JSDoc> was created without expected prop 'jsdoc'");
		}
	}

	get jsdoc() {
		throw new Error("<JSDoc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set jsdoc(value) {
		throw new Error("<JSDoc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get showHeader() {
		throw new Error("<JSDoc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showHeader(value) {
		throw new Error("<JSDoc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { JSDoc as a };
